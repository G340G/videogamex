<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>ENTROPY.DAT</title>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

  <style>
    body{
      background:#050505;color:#a8b5b2;font-family:'VT323',monospace;
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      height:100vh;margin:0;overflow:hidden;user-select:none;
    }
    .crt-monitor{position:relative;border:1px solid #333;box-shadow:0 0 20px rgba(0,0,0,.8);width:640px;height:480px;background:#000}
    canvas{width:100%;height:100%;background:#000;display:block;image-rendering:pixelated}
    .scanlines{position:absolute;inset:0;background:linear-gradient(to bottom,rgba(255,255,255,0),rgba(255,255,255,0) 50%,rgba(0,0,0,.22) 50%,rgba(0,0,0,.22));background-size:100% 4px;pointer-events:none;z-index:10}
    .crt-monitor::after{content:" ";position:absolute;inset:0;background:rgba(18,16,16,.10);opacity:0;z-index:10;pointer-events:none;animation:flicker .14s infinite}
    @keyframes flicker{0%{opacity:.02}50%{opacity:.06}100%{opacity:.02}}
    #game-ui{position:absolute;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;z-index:20;color:#ccffcc;text-shadow:0 0 5px #ccffcc;font-size:1.5rem;pointer-events:none}
    .controls-hint{margin-top:20px;text-align:center;opacity:.55;font-size:1.2rem}
    .start-overlay{position:absolute;inset:0;z-index:30;display:grid;place-items:center;background:radial-gradient(circle at center,rgba(0,0,0,.35),rgba(0,0,0,.92));color:#ccffcc;text-shadow:0 0 8px rgba(204,255,204,.35);cursor:pointer}
    .start-title{font-size:4rem;letter-spacing:2px;margin-bottom:10px;text-align:center}
    .start-sub{font-size:1.8rem;opacity:.9;text-align:center}
    .small{font-size:1.2rem;opacity:.65}
  </style>
</head>
<body>
  <div class="crt-monitor" id="crt">
    <div class="scanlines"></div>
    <div id="game-ui">
      <span id="score-display">OFFERINGS: 0/3</span>
      <span id="status-display">STATUS: ALONE</span>
    </div>
    <canvas id="gameCanvas" width="320" height="240"></canvas>
    <div id="startOverlay" class="start-overlay" tabindex="0" role="button" aria-label="Start game">
      <div>
        <div class="start-title">ENTROPY.DAT</div>
        <div class="start-sub">CLICK TO INITIALIZE</div>
        <div class="start-sub small">WASD / Arrows · Shift run · E pulse</div>
        <div class="start-sub small">1/2 respond to messages</div>
      </div>
    </div>
  </div>
  <div class="controls-hint">
    WASD / Arrows to Move · Shift to Run (louder) · E = Signal Pulse.<br/>
    Chests unlock missions. Clear mission to open the exit.
  </div>

<script>
(() => {
  // ===== CONFIG =====
  const TILE_SIZE = 16;
  const COLS = 20;
  const ROWS = 15;

  const TOTAL_OFFERINGS = 3;
  const CHESTS_PER_LEVEL = 3;

  const BASE_FOV = 6;
  const MIN_FOV  = 4.2;
  const MAX_FOV  = 7.0;

  // ===== DOM / CANVAS =====
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha:false });

  const statusDisplay = document.getElementById('status-display');
  const scoreDisplay  = document.getElementById('score-display');
  const startOverlay  = document.getElementById('startOverlay');

  // ===== STATE =====
  let map = [];
  let keys = {};

  let player = { x:1, y:1, speed:0.08, panicHits:0, panicGrace:0, sanity: 100 };

  let offerings = [];
  let collectedCount = 0;
  let exit = null; // {x,y}
  let exitLocked = true;

  let chests = []; // {x,y,opened:false}

  let stains = []; // corruption zones

  let messages = []; // floating glitch text
  let globalAnxiety = 0;

  // lore prompt with choice
  let prompt = {
    active:false,
    text:"",
    a:"",
    b:"",
    onChoose:null,
    timer:0
  };

  // missions (unlocked via chests)
  let mission = {
    active:false,
    title:"",
    desc:"",
    type:"",
    progress:0,
    goal:1,
    extra:null,
    completed:false
  };

  // signal pulse
  let pulse = { active:false, t:0, dirX:0, dirY:0 };

  // full-screen creepy image flash
  let flash = { active:false, t:0, dur:0.9, img:null, alpha:0 };

  // Enemy as creepy image sprite
  let enemy = {
    x:-1, y:-1,
    active:false,
    speed:0.020,
    stun:0,
    lastSeen:0,
    stepCooldown:0,
    targetTile:null,
    aggression: 1.0
  };

  let gameStarted = false;

  // ===== TEXT BANK =====
  const crypticPhrases = [
    "IT KNOWS","BEHIND YOU","NULL REFERENCE","WHERE AM I","DONT STOP","STATIC...","1997",
    "DE-SYNC","LOST SIGNAL","FRAME DROP","NO CLIP","PAINTED AIR","NEGATIVE SPACE","FRACTURE","MUTE COLOR",
    "DOOR IS NOT A DOOR","EYES IN THE FOG","YOU ARE DATA","THE MAZE REMEMBERS"
  ];

  const lorePrompts = [
    {
      text: "A voice leaks from the wall: \"DO YOU WANT TO BE SEEN?\"",
      a: "1) YES (more clarity)",
      b: "2) NO (more safety)",
      choose: (c) => {
        if (c===1){ player.sanity = Math.min(100, player.sanity + 12); globalAnxiety = Math.max(globalAnxiety, 10); enemy.aggression += 0.12; triggerMessage("YOU ARE VISIBLE"); }
        else { enemy.aggression = Math.max(0.8, enemy.aggression - 0.10); triggerMessage("YOU ARE MISSING"); }
      }
    },
    {
      text: "The CRT whispers: \"SACRIFICE SPEED FOR SILENCE?\"",
      a: "1) ACCEPT (slower run, calmer)",
      b: "2) REFUSE (faster run, louder)",
      choose: (c) => {
        if (c===1){ player.speed = Math.max(0.07, player.speed - 0.01); globalAnxiety = Math.max(0, globalAnxiety - 3); triggerMessage("SILENCE TRADE"); }
        else { player.speed = Math.min(0.095, player.speed + 0.008); enemy.aggression += 0.10; triggerMessage("LOUD TRADE"); }
      }
    },
    {
      text: "A stain pulses: \"NAME THE COLOR.\"",
      a: "1) RED",
      b: "2) NONE",
      choose: (c) => {
        if (c===1){ globalAnxiety = Math.max(globalAnxiety, 14); triggerMessage("WRONG"); enemy.aggression += 0.08; }
        else { triggerMessage("CORRECT"); player.sanity = Math.min(100, player.sanity + 8); }
      }
    }
  ];

  // ===== INPUT =====
  window.addEventListener('keydown', (e) => {
    keys[e.code] = true;

    if (!gameStarted && (e.code === "Enter" || e.code === "Space")) startGame();

    if (gameStarted && e.code === "KeyE") triggerPulse();

    // respond to prompts
    if (prompt.active) {
      if (e.code === "Digit1" || e.code === "KeyY") choosePrompt(1);
      if (e.code === "Digit2" || e.code === "KeyN") choosePrompt(2);
    }
  }, { passive:true });

  window.addEventListener('keyup', (e) => keys[e.code] = false, { passive:true });

  startOverlay.addEventListener("pointerdown", (e)=>{ e.preventDefault(); if(!gameStarted) startGame(); });
  canvas.addEventListener("pointerdown", (e)=>{ e.preventDefault(); if(!gameStarted) startGame(); });

  // ===== AUDIO (same engine + extra behaviors) =====
  let audio = null;

  function initAudio(){
    if (audio) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    const ac = new AC();

    const master = ac.createGain();
    master.gain.value = 0.70;

    const pan = ac.createStereoPanner();
    pan.pan.value = 0;
    master.connect(pan);
    pan.connect(ac.destination);

    const noiseBuf = ac.createBuffer(1, ac.sampleRate * 2, ac.sampleRate);
    {
      const d = noiseBuf.getChannelData(0);
      let last = 0;
      for (let i=0;i<d.length;i++){
        last = 0.97*last + 0.03*(Math.random()*2-1);
        d[i] = last;
      }
    }

    // wind
    const wind = ac.createBufferSource(); wind.buffer = noiseBuf; wind.loop = true;
    const windLP = ac.createBiquadFilter(); windLP.type="lowpass"; windLP.frequency.value=220;
    const windGain = ac.createGain(); windGain.gain.value=0.05;
    wind.connect(windLP); windLP.connect(windGain); windGain.connect(master); wind.start();

    // static
    const staticSrc = ac.createBufferSource(); staticSrc.buffer=noiseBuf; staticSrc.loop=true;
    const staticBP = ac.createBiquadFilter(); staticBP.type="bandpass"; staticBP.frequency.value=1300; staticBP.Q.value=0.8;
    const staticGain = ac.createGain(); staticGain.gain.value=0.02;
    staticSrc.connect(staticBP); staticBP.connect(staticGain); staticGain.connect(master); staticSrc.start();

    // drone
    const drone = ac.createOscillator(); drone.type="sine"; drone.frequency.value=55;
    const mod = ac.createOscillator(); mod.type="sine"; mod.frequency.value=0.12;
    const modGain = ac.createGain(); modGain.gain.value = 18;
    mod.connect(modGain); modGain.connect(drone.frequency);
    const droneLP = ac.createBiquadFilter(); droneLP.type="lowpass"; droneLP.frequency.value=520;
    const droneGain = ac.createGain(); droneGain.gain.value=0.03;
    drone.connect(droneLP); droneLP.connect(droneGain); droneGain.connect(master);
    drone.start(); mod.start();

    function blip(intensity=0.4){
      const t = ac.currentTime;
      const o = ac.createOscillator();
      o.type = Math.random()<0.5 ? "square":"triangle";
      o.frequency.value = 120 + Math.random()*1600;

      const bp = ac.createBiquadFilter();
      bp.type="bandpass"; bp.frequency.value = 400 + Math.random()*2800; bp.Q.value=8;

      const g = ac.createGain();
      g.gain.setValueAtTime(0,t);
      g.gain.linearRampToValueAtTime(0.09*intensity, t+0.002);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.08);

      o.connect(bp); bp.connect(g); g.connect(master);
      o.start(t); o.stop(t+0.09);
    }

    function mutate(){
      const t = ac.currentTime;
      staticBP.frequency.setTargetAtTime(700 + Math.random()*3000, t, 1.8);
      staticGain.gain.setTargetAtTime(0.012 + Math.random()*0.03, t, 1.2);
      windLP.frequency.setTargetAtTime(120 + Math.random()*320, t, 2.5);
      drone.frequency.setTargetAtTime(35 + Math.random()*55, t, 2.0);
      droneLP.frequency.setTargetAtTime(250 + Math.random()*900, t, 2.0);
      droneGain.gain.setTargetAtTime(0.018 + Math.random()*0.06, t, 2.0);

      if (Math.random()<0.12){
        drone.detune.setTargetAtTime((Math.random()<0.5?-1:1)*(80+Math.random()*180), t, 0.6);
        setTimeout(()=>drone.detune.setTargetAtTime(0, ac.currentTime, 0.9), 900+Math.random()*1400);
      }
      setTimeout(mutate, 900 + Math.random()*1600);
    }

    function eventTick(){
      const fear = audio?.fear ?? 0;
      if (Math.random() < 0.16 + fear*0.30) blip(0.2 + Math.random()*(0.5 + fear));
      setTimeout(eventTick, 240 + Math.random()*(900 - fear*420));
    }

    audio = {
      ac, fear:0, blip,
      setFear(f){
        audio.fear = f;
        const t = ac.currentTime;
        staticGain.gain.setTargetAtTime(0.015 + f*0.10, t, 0.08);
        staticBP.Q.setTargetAtTime(0.8 + f*9, t, 0.15);
        windGain.gain.setTargetAtTime(0.04 + f*0.08, t, 0.12);
        droneGain.gain.setTargetAtTime(0.02 + f*0.09, t, 0.2);
        if (f>0.70 && Math.random()<0.07) blip(0.7*f);
      },
      setObjectivePan(p){
        pan.pan.setTargetAtTime(Math.max(-1, Math.min(1, p)), ac.currentTime, 0.15);
      }
    };

    setTimeout(mutate, 500);
    setTimeout(eventTick, 700);
  }

  async function ensureAudioRunning(){
    initAudio();
    if (audio?.ac?.state === "suspended"){
      try { await audio.ac.resume(); } catch {}
    }
  }

  // ===== MAP / HELPERS =====
  const clamp = (v,a,b)=> v<a?a : v>b?b : v;
  const inBounds = (x,y)=> x>=0 && y>=0 && x<COLS && y<ROWS;
  const isFloor = (x,y)=> inBounds(x,y) && map[y][x] === 0;

  function randomFloorFarFrom(px, py, minManhattan){
    for (let i=0;i<600;i++){
      const x = (Math.random()*COLS)|0;
      const y = (Math.random()*ROWS)|0;
      if (!isFloor(x,y)) continue;
      if (Math.abs(x-px)+Math.abs(y-py) < minManhattan) continue;
      return {x,y};
    }
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        if (isFloor(x,y) && Math.abs(x-px)+Math.abs(y-py) >= minManhattan) return {x,y};
      }
    }
    return {x:1,y:1};
  }

  function checkWall(x,y){
    const ax=Math.floor(x+0.2), ay=Math.floor(y+0.2);
    const bx=Math.floor(x+0.8), by=Math.floor(y+0.8);
    if (!inBounds(ax,ay) || !inBounds(bx,by)) return true;
    return map[ay][ax]===1 || map[by][ax]===1 || map[ay][bx]===1 || map[by][bx]===1;
  }

  function triggerMessage(text=null){
    if (Math.random() > 0.38 && !text) return;
    const phrase = text || crypticPhrases[(Math.random()*crypticPhrases.length)|0];
    messages.push({
      text: phrase,
      x: Math.random()*canvas.width,
      y: Math.random()*canvas.height,
      life: 60,
      color: Math.random()>0.5 ? "#ff2244" : "#ffffff"
    });
  }

  function updateUI(){
    scoreDisplay.innerText = `OFFERINGS: ${collectedCount}/${TOTAL_OFFERINGS}  |  CHESTS: ${openedChests()}/${CHESTS_PER_LEVEL}`;
  }

  function openedChests(){
    return chests.filter(c=>c.opened).length;
  }

  // ===== MISSION SYSTEM =====
  function setMission(m){
    mission.active = true;
    mission.completed = false;
    mission.title = m.title;
    mission.desc  = m.desc;
    mission.type  = m.type;
    mission.progress = 0;
    mission.goal = m.goal ?? 1;
    mission.extra = m.extra ?? null;

    exitLocked = true;
    statusDisplay.style.color = "#ccffcc";
    statusDisplay.innerText = "STATUS: MISSION ACTIVE";
    triggerMessage("NEW TASK LOADED");
  }

  function completeMission(){
    mission.completed = true;
    mission.active = false;
    exitLocked = false;
    triggerMessage("TASK COMPLETE");
    triggerMessage("EXIT UNSEALED");
    audio?.blip?.(1.0);
    statusDisplay.style.color = "#ccffcc";
    statusDisplay.innerText = "STATUS: EXIT UNLOCKED";
    // reward: reduce aggression a bit
    enemy.aggression = Math.max(0.85, enemy.aggression - 0.08);
    globalAnxiety = Math.max(0, globalAnxiety - 4);
  }

  function generateRandomMission(){
    // always different flavor
    const types = ["STILLNESS", "NO_RUN", "STAIN_TOUCH", "ECHO_COUNT", "FOLLOW_ORDER"];
    const t = types[(Math.random()*types.length)|0];

    if (t === "STILLNESS"){
      const seconds = 2.0 + Math.random()*2.0;
      return {
        type: "STILLNESS",
        title: "STILLNESS RITUAL",
        desc: `Stand completely still near a stain for ${seconds.toFixed(1)}s.\n(Do not move.)`,
        goal: seconds,
        extra: { seconds }
      };
    }

    if (t === "NO_RUN"){
      const time = 8 + ((Math.random()*10)|0);
      return {
        type:"NO_RUN",
        title:"SILENT WALK",
        desc:`Survive ${time}s without sprinting.\n(Shift forbidden.)`,
        goal: time,
        extra: { time }
      };
    }

    if (t === "STAIN_TOUCH"){
      const count = 2 + ((Math.random()*3)|0);
      return {
        type:"STAIN_TOUCH",
        title:"TOUCH THE CORRUPTION",
        desc:`Step into ${count} different stains.\n(Each stain counts once.)`,
        goal: count,
        extra: { touched: new Set() }
      };
    }

    if (t === "ECHO_COUNT"){
      const pulses = 2 + ((Math.random()*3)|0);
      return {
        type:"ECHO_COUNT",
        title:"ECHO TEST",
        desc:`Use Signal Pulse (E) exactly ${pulses} times.\n(Too many resets the mission.)`,
        goal: pulses,
        extra: { used:0, max:pulses }
      };
    }

    // FOLLOW_ORDER: assign order to offerings
    const order = [1,2,3].sort(()=>Math.random()-0.5);
    offerings.forEach((o,i)=>o.order = order[i]);
    return {
      type:"FOLLOW_ORDER",
      title:"SEQUENCE OF OFFERINGS",
      desc:`Collect offerings in the correct sequence.\n(Colors indicate order.)`,
      goal: TOTAL_OFFERINGS,
      extra: { needed:1 }
    };
  }

  function updateMission(dt, moving, sprinting){
    if (!mission.active) return;

    // Mission text box is drawn in render; here we update logic.
    if (mission.type === "STILLNESS"){
      // near any stain + not moving
      const near = stains.some(s => Math.hypot((s.x+0.5)-player.x, (s.y+0.5)-player.y) < 2.0);
      if (!moving && near) mission.progress += dt;
      else mission.progress = Math.max(0, mission.progress - dt*0.8);

      if (mission.progress >= mission.goal) completeMission();
      return;
    }

    if (mission.type === "NO_RUN"){
      if (sprinting){
        mission.progress = Math.max(0, mission.progress - dt*2.0);
        globalAnxiety = Math.max(globalAnxiety, 12);
        if (Math.random()<0.02) triggerMessage("TOO LOUD");
      } else {
        mission.progress += dt;
      }
      if (mission.progress >= mission.goal) completeMission();
      return;
    }

    if (mission.type === "STAIN_TOUCH"){
      for (const s of stains){
        const d = Math.hypot((s.x+0.5)-player.x, (s.y+0.5)-player.y);
        if (d < 0.9) mission.extra.touched.add(`${s.x},${s.y}`);
      }
      mission.progress = mission.extra.touched.size;
      if (mission.progress >= mission.goal) completeMission();
      return;
    }

    if (mission.type === "ECHO_COUNT"){
      mission.progress = mission.extra.used;
      if (mission.progress >= mission.goal) completeMission();
      return;
    }

    if (mission.type === "FOLLOW_ORDER"){
      // handled during pickups; keep display in sync
      mission.progress = collectedCount;
      if (collectedCount >= TOTAL_OFFERINGS && !exitLocked) {
        // already unlocked by completion; ignore
      }
      return;
    }
  }

  // ===== LORE PROMPT SYSTEM =====
  function showPrompt(p){
    if (prompt.active) return;
    prompt.active = true;
    prompt.text = p.text;
    prompt.a = p.a;
    prompt.b = p.b;
    prompt.onChoose = p.choose;
    prompt.timer = 6.5; // seconds to respond
    triggerMessage("INPUT REQUIRED");
    globalAnxiety = Math.max(globalAnxiety, 10);
  }

  function choosePrompt(choice){
    if (!prompt.active) return;
    const fn = prompt.onChoose;
    prompt.active = false;
    if (fn) fn(choice);
    audio?.blip?.(0.9);
  }

  // ===== CREEPY IMAGE FLASH (procedural) =====
  function generateCreepyImage(){
    // offscreen canvas
    const c = document.createElement('canvas');
    c.width = 160; c.height = 120;
    const g = c.getContext('2d');

    // background noise
    g.fillStyle = "#000"; g.fillRect(0,0,c.width,c.height);
    for (let i=0;i<2400;i++){
      const x = (Math.random()*c.width)|0;
      const y = (Math.random()*c.height)|0;
      const v = (Math.random()*60)|0;
      g.fillStyle = `rgb(${v},${v},${v})`;
      g.fillRect(x,y,1,1);
    }

    // abstract “face”
    const cx = c.width/2 + (Math.random()*18-9);
    const cy = c.height/2 + (Math.random()*12-6);

    // eyes
    const eyeY = cy - 10 + Math.random()*8;
    const eyeDX = 28 + Math.random()*10;
    g.fillStyle = "rgba(255,60,90,0.65)";
    g.fillRect(cx - eyeDX, eyeY, 8, 4);
    g.fillRect(cx + eyeDX - 8, eyeY, 8, 4);

    // pupils
    g.fillStyle = "rgba(0,0,0,0.9)";
    g.fillRect(cx - eyeDX + 3, eyeY+1, 2, 2);
    g.fillRect(cx + eyeDX - 5, eyeY+1, 2, 2);

    // mouth
    g.fillStyle = "rgba(255,255,255,0.10)";
    g.fillRect(cx - 22, cy + 14, 44, 3);

    // vertical “tears”
    g.fillStyle = "rgba(255,60,90,0.22)";
    for (let i=0;i<6;i++){
      const x = cx + (Math.random()*90-45);
      const y = (Math.random()*c.height)|0;
      g.fillRect(x, y, 1, 10 + (Math.random()*40|0));
    }

    // smear
    g.globalAlpha = 0.18;
    for (let i=0;i<6;i++){
      const y = (Math.random()*c.height)|0;
      const dx = (Math.random()*20-10);
      g.drawImage(c, 0, y, c.width, 2, dx, y, c.width, 2);
    }
    g.globalAlpha = 1;

    return c;
  }

  function triggerFlash(){
    flash.active = true;
    flash.t = 0;
    flash.dur = 0.7 + Math.random()*0.7;
    flash.img = generateCreepyImage();
    flash.alpha = 0;
  }

  // ===== MONSTER SPRITE (procedural “creepy image”) =====
  function makeMonsterSprite(){
    const c = document.createElement('canvas');
    c.width = 16; c.height = 16;
    const g = c.getContext('2d');

    // base
    g.fillStyle = "rgba(0,0,0,0)";
    g.clearRect(0,0,16,16);

    // head
    g.fillStyle = "rgba(40,40,55,0.9)";
    g.fillRect(3,3,10,10);

    // eyes (red)
    g.fillStyle = "rgba(255,60,90,0.8)";
    g.fillRect(5,7,2,1);
    g.fillRect(9,7,2,1);

    // mouth (void)
    g.fillStyle = "rgba(0,0,0,0.85)";
    g.fillRect(6,10,4,2);

    // noise specks
    for (let i=0;i<20;i++){
      const x = (Math.random()*16)|0;
      const y = (Math.random()*16)|0;
      g.fillStyle = Math.random()<0.5 ? "rgba(255,60,90,0.12)" : "rgba(255,255,255,0.08)";
      g.fillRect(x,y,1,1);
    }
    return c;
  }
  const monsterSprite = makeMonsterSprite();

  // ===== SIGNAL PULSE =====
  function getNearestObjective(){
    // nearest unopened chest takes priority, else offering, else exit
    let best=null, bestD=1e9;

    for (const c of chests){
      if (c.opened) continue;
      const d = Math.hypot((c.x+0.5)-player.x, (c.y+0.5)-player.y);
      if (d<bestD){ bestD=d; best={x:c.x,y:c.y}; }
    }
    if (best) return best;

    for (const o of offerings){
      if (o.collected) continue;
      const d = Math.hypot((o.x+0.5)-player.x, (o.y+0.5)-player.y);
      if (d<bestD){ bestD=d; best={x:o.x,y:o.y}; }
    }
    if (!best && exit) best = {x:exit.x, y:exit.y};
    return best;
  }

  function triggerPulse(){
    if (!gameStarted) return;
    if (pulse.active) return;

    const target = getNearestObjective();
    if (!target) return;

    const dx = (target.x+0.5) - player.x;
    const dy = (target.y+0.5) - player.y;
    const d = Math.max(0.0001, Math.hypot(dx,dy));

    pulse.active = true;
    pulse.t = 0;
    pulse.dirX = dx/d;
    pulse.dirY = dy/d;

    globalAnxiety = Math.max(globalAnxiety, 10);
    triggerMessage("ECHO PULSE");
    audio?.blip?.(1.0);

    // mission hook
    if (mission.active && mission.type === "ECHO_COUNT"){
      mission.extra.used++;
      if (mission.extra.used > mission.extra.max){
        // too many -> reset mission progress
        mission.extra.used = 0;
        triggerMessage("ECHO OVERFLOW");
        globalAnxiety = Math.max(globalAnxiety, 16);
      }
    }
  }

  // ===== ENEMY AI (grid guided) =====
  function enemyPickStepToward(tx,ty){
    const ex = enemy.x|0, ey = enemy.y|0;
    const opts = [
      {x:ex+1,y:ey},{x:ex-1,y:ey},{x:ex,y:ey+1},{x:ex,y:ey-1}
    ].filter(p=>isFloor(p.x,p.y));
    if (!opts.length) return null;

    let best=opts[0], bestScore=1e9;
    for (const o of opts){
      const d = Math.hypot((o.x+0.5)-tx,(o.y+0.5)-ty);
      const wob = (Math.random()-0.5)*0.35;
      const score = d + wob;
      if (score<bestScore){ bestScore=score; best=o; }
    }
    return best;
  }

  function spawnEnemy(){
    const ptx = player.x|0, pty = player.y|0;
    const r = randomFloorFarFrom(ptx,pty, 14);
    enemy.x = r.x+0.5;
    enemy.y = r.y+0.5;
    enemy.active = true;
    enemy.stun = 0;
    enemy.lastSeen = 0;
    enemy.stepCooldown = 0;
    enemy.targetTile = null;
    statusDisplay.innerText = "STATUS: WATCHED";
    statusDisplay.style.color = "#ff3344";
    audio?.blip?.(0.9);
  }

  function updateEnemy(){
    if (!enemy.active && collectedCount >= 1) spawnEnemy();
    if (!enemy.active) return;

    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const dist = Math.max(0.0001, Math.hypot(dx,dy));

    const fear = clamp(1 - dist/6, 0, 1);
    audio?.setFear?.(fear);

    if (enemy.stun > 0){ enemy.stun--; return; }

    const sprinting = !!keys["ShiftLeft"];
    const hearRadius = sprinting ? 7.8 : 4.6;

    if (dist < 3){
      globalAnxiety = Math.max(globalAnxiety, 9 + (3-dist)*6);
      if (Math.random()<0.05) triggerMessage();
    }

    // tracking
    let targetX = enemy.x, targetY = enemy.y;
    if (dist < hearRadius){
      enemy.lastSeen = 80;
      targetX = player.x; targetY = player.y;
    } else if (enemy.lastSeen > 0){
      enemy.lastSeen--;
      targetX = enemy.x + (dx/dist)*1.0;
      targetY = enemy.y + (dy/dist)*1.0;
    } else {
      // drift toward stains (creepy behavior)
      const s = stains[(Math.random()*stains.length)|0];
      targetX = s.x+0.5; targetY = s.y+0.5;
    }

    enemy.stepCooldown--;
    if (enemy.stepCooldown <= 0 || !enemy.targetTile){
      enemy.stepCooldown = 9 + ((Math.random()*10)|0);
      const step = enemyPickStepToward(targetX, targetY);
      if (step) enemy.targetTile = step;
    }

    const spd = enemy.speed * enemy.aggression;
    if (enemy.targetTile){
      const cx = enemy.targetTile.x+0.5;
      const cy = enemy.targetTile.y+0.5;
      const mdx = cx - enemy.x;
      const mdy = cy - enemy.y;
      const md  = Math.max(0.0001, Math.hypot(mdx,mdy));
      enemy.x += (mdx/md)*spd;
      enemy.y += (mdy/md)*spd;
      if (md < 0.12) enemy.stepCooldown = 0;
    }

    // rare “image-lurch” when sprinting
    if (sprinting && fear > 0.45 && Math.random() < 0.006){
      enemy.x += (dx/dist)*0.50;
      enemy.y += (dy/dist)*0.50;
      triggerMessage("IMAGE TEAR");
      globalAnxiety = Math.max(globalAnxiety, 18);
      audio?.blip?.(1.0);
      triggerFlash();
    }

    // panic hits (2 strikes)
    if (player.panicGrace > 0) player.panicGrace--;

    if (dist < 0.60 && player.panicGrace <= 0){
      player.panicGrace = 55;
      enemy.stun = 40;
      globalAnxiety = Math.max(globalAnxiety, 22);

      triggerMessage("DON'T LOOK");
      audio?.blip?.(1.0);
      triggerFlash();

      // shove back
      player.x -= (dx/dist)*0.35;
      player.y -= (dy/dist)*0.35;

      player.panicHits++;
      player.sanity = Math.max(0, player.sanity - 18);

      if (player.panicHits >= 2){
        alert("CAUGHT. RESETTING.");
        generateLevel();
      }
    }

    if (player.panicHits > 0 && dist > 4.5){
      player.panicHits = Math.max(0, player.panicHits - 0.0025);
    }
  }

  // ===== LEVEL GEN =====
  function generateLevel(){
    // maze init
    map = Array(ROWS).fill(0).map(()=>Array(COLS).fill(1));
    const stack=[];
    const start={x:1,y:1};
    map[start.y][start.x]=0;
    stack.push(start);

    while(stack.length){
      const c = stack[stack.length-1];
      const dirs = [
        {dx:0,dy:-2},{dx:0,dy:2},{dx:-2,dy:0},{dx:2,dy:0}
      ].sort(()=>Math.random()-0.5);

      let carved=false;
      for(const d of dirs){
        const nx=c.x+d.dx, ny=c.y+d.dy;
        if(nx>0 && nx<COLS-1 && ny>0 && ny<ROWS-1 && map[ny][nx]===1){
          map[ny][nx]=0;
          map[c.y+(d.dy/2)][c.x+(d.dx/2)]=0;
          stack.push({x:nx,y:ny});
          carved=true;
          break;
        }
      }
      if(!carved) stack.pop();
    }

    // stains
    stains=[];
    for(let i=0;i<8;i++){
      stains.push(randomFloorFarFrom(1,1,4));
    }

    // offerings
    offerings=[];
    while(offerings.length<TOTAL_OFFERINGS){
      const r = randomFloorFarFrom(1,1,6);
      if(offerings.some(o=>o.x===r.x && o.y===r.y)) continue;
      offerings.push({x:r.x,y:r.y,collected:false,order:0});
    }

    // chests
    chests=[];
    while(chests.length<CHESTS_PER_LEVEL){
      const r = randomFloorFarFrom(1,1,5);
      if(chests.some(c=>c.x===r.x && c.y===r.y)) continue;
      if(offerings.some(o=>o.x===r.x && o.y===r.y)) continue;
      chests.push({x:r.x,y:r.y,opened:false});
    }

    // player
    player.x=1; player.y=1;
    player.panicHits=0; player.panicGrace=0;
    player.sanity = 100;

    // exit
    exit = randomFloorFarFrom(1,1,12);
    exitLocked = true;

    // reset counts
    collectedCount = 0;
    messages = [];
    globalAnxiety = 0;

    // enemy reset
    enemy.active=false;
    enemy.stun=0;
    enemy.lastSeen=0;
    enemy.stepCooldown=0;
    enemy.targetTile=null;
    enemy.speed = 0.018 + Math.random()*0.008;
    enemy.aggression = 0.95 + Math.random()*0.18;

    // mission reset
    mission.active = false;
    mission.completed = false;

    // prompt reset
    prompt.active = false;

    // pulse/flash
    pulse.active=false;
    flash.active=false;

    statusDisplay.style.color="#ccffcc";
    statusDisplay.innerText="STATUS: ALONE";

    updateUI();
  }

  // ===== PICKUPS =====
  function openChest(ch){
    ch.opened = true;
    triggerMessage("CHEST OPENED");
    audio?.blip?.(1.0);
    if (Math.random() < 0.75) triggerFlash();

    // unlock a mission if none active
    if (!mission.active && exitLocked){
      setMission(generateRandomMission());
    } else {
      // if a mission is already active, chest can trigger lore prompt instead
      if (Math.random() < 0.65) showPrompt(lorePrompts[(Math.random()*lorePrompts.length)|0]);
    }
  }

  function collectOffering(o){
    // if FOLLOW_ORDER mission is active, enforce order
    if (mission.active && mission.type === "FOLLOW_ORDER"){
      const needed = (mission.extra?.needed ?? 1);
      if (o.order !== needed){
        triggerMessage("WRONG SEQUENCE");
        globalAnxiety = Math.max(globalAnxiety, 18);
        audio?.blip?.(1.0);
        triggerFlash();
        generateLevel();
        return;
      }
      mission.extra.needed = needed + 1;
      if (mission.extra.needed > TOTAL_OFFERINGS){
        // complete mission here
        completeMission();
      }
    }

    o.collected = true;
    collectedCount++;
    triggerMessage("OFFERING ACCEPTED");
    triggerMessage(["MEMORY FRAME: 00"+((Math.random()*9)|0), "FOUND FOOTAGE: OK", "INDEX CORRUPTED"][((Math.random()*3)|0)]);
    audio?.blip?.(0.9);

    if (Math.random() < 0.55) triggerFlash();
    if (Math.random() < 0.30) showPrompt(lorePrompts[(Math.random()*lorePrompts.length)|0]);

    updateUI();
  }

  // ===== NOISE OVERLAY =====
  function drawNoiseOverlay(amount){
    if (amount<=0) return;
    ctx.save();
    ctx.globalAlpha = Math.min(0.26, amount/50);
    for(let i=0;i<150;i++){
      const x=Math.random()*canvas.width;
      const y=Math.random()*canvas.height;
      const w=1+Math.random()*2;
      const h=1+Math.random()*2;
      ctx.fillStyle = Math.random()<0.5 ? "#0d0d0d" : "#1a1a1a";
      ctx.fillRect(x,y,w,h);
    }
    ctx.restore();
  }

  // ===== UPDATE =====
  let lastTime = performance.now();

  function update(){
    const now = performance.now();
    const dt = Math.min(0.05, (now-lastTime)/1000);
    lastTime = now;

    // prompt timer
    if (prompt.active){
      prompt.timer -= dt;
      if (prompt.timer <= 0){
        // no response -> punish gently
        prompt.active = false;
        triggerMessage("NO RESPONSE");
        globalAnxiety = Math.max(globalAnxiety, 14);
        enemy.aggression += 0.06;
      }
    }

    // movement
    let vx=0, vy=0;
    let spd = player.speed;
    const sprinting = !!keys["ShiftLeft"];
    if (sprinting){
      spd *= 1.5;
      globalAnxiety = Math.min(globalAnxiety + 0.35, 16);
      player.sanity = Math.max(0, player.sanity - 8*dt);
    } else {
      globalAnxiety = Math.max(globalAnxiety - 0.12, 0);
      player.sanity = Math.min(100, player.sanity + 5*dt);
    }

    if (keys["KeyW"]||keys["ArrowUp"]) vy=-spd;
    if (keys["KeyS"]||keys["ArrowDown"]) vy=spd;
    if (keys["KeyA"]||keys["ArrowLeft"]) vx=-spd;
    if (keys["KeyD"]||keys["ArrowRight"]) vx=spd;

    const nx = player.x + vx;
    const ny = player.y + vy;
    if (!checkWall(nx, player.y)) player.x = nx;
    if (!checkWall(player.x, ny)) player.y = ny;

    const moving = Math.abs(vx)+Math.abs(vy) > 0.00001;

    // update mission
    updateMission(dt, moving, sprinting);

    // enemy
    updateEnemy();

    // objective panning
    const obj = getNearestObjective();
    if (obj && audio){
      const dx = (obj.x+0.5) - player.x;
      audio.setObjectivePan(clamp(dx/6, -1, 1));
    }

    // stains effects + chance of lore prompt
    for (const s of stains){
      const d = Math.hypot((s.x+0.5)-player.x, (s.y+0.5)-player.y);
      if (d < 1.0){
        globalAnxiety = Math.max(globalAnxiety, 8);
        if (Math.random() < 0.015) triggerMessage("COLOR BLEED");
        if (Math.random() < 0.010) audio?.blip?.(0.35);
        if (Math.random() < 0.004) showPrompt(lorePrompts[(Math.random()*lorePrompts.length)|0]);
      }
    }

    // chest pickup (CONTINUED)
    for (const c of chests){
      if(c.opened) continue;
      const d = Math.hypot((c.x+0.5)-player.x, (c.y+0.5)-player.y);
      if(d < 0.8) openChest(c);
    }

    // offering pickup
    for (const o of offerings){
      if(!o.collected){
        const d = Math.hypot((o.x+0.5)-player.x, (o.y+0.5)-player.y);
        if(d < 0.8) collectOffering(o);
      }
    }

    // Exit check
    if(exit && !exitLocked){
      const d = Math.hypot((exit.x+0.5)-player.x, (exit.y+0.5)-player.y);
      if(d < 0.6) {
        // WIN STATE
        gameStarted = false;
        alert("SEQUENCE COMPLETE. DATA UPLOADED.");
        location.reload();
      }
    }

    // Pulse expansion
    if(pulse.active){
      pulse.t += dt * 12; // wave speed
      if(pulse.t > 25) pulse.active = false;
    }

    // Flash fade
    if(flash.active){
      flash.t += dt;
      // attack/decay curve for alpha
      if(flash.t < flash.dur * 0.2) flash.alpha = flash.t / (flash.dur * 0.2);
      else flash.alpha = 1 - (flash.t - flash.dur * 0.2) / (flash.dur * 0.8);
      
      if(flash.t >= flash.dur) {
        flash.active = false;
        flash.alpha = 0;
      }
    }

    // Message life
    for(let i=messages.length-1; i>=0; i--){
      messages[i].life--;
      if(messages[i].life<=0) messages.splice(i,1);
    }
  }

  // ===== RENDER =====
  function render(){
    // 1. Clear
    ctx.fillStyle = "#050505";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // 2. Camera/FOV calc
    // "Fog of war" radius varies by anxiety
    const viewRadius = clamp(BASE_FOV - (globalAnxiety/5) + (pulse.active?2.5:0), MIN_FOV, MAX_FOV);

    // 3. Draw Map Layer
    // We iterate tiles and check distance to player to determine visibility (simple LOS)
    for(let y=0; y<ROWS; y++){
      for(let x=0; x<COLS; x++){
        const dist = Math.hypot(x+0.5 - player.x, y+0.5 - player.y);
        
        let vis = 0;
        if(dist < viewRadius) {
           // quadratic falloff
           vis = 1 - (dist/viewRadius);
           vis = Math.pow(vis, 0.6); 
        }

        // Pulse Effect: light up tiles in a ring
        if(pulse.active){
          const pd = dist; 
          // ring thickness ~1.5
          if(Math.abs(pd - pulse.t) < 1.5) {
            vis += 0.5 * (1 - (Math.abs(pd - pulse.t)/1.5));
          }
        }

        if(vis <= 0.01) continue;
        vis = clamp(vis, 0, 1);

        const sx = x * TILE_SIZE;
        const sy = y * TILE_SIZE;
        
        ctx.save();
        ctx.globalAlpha = vis;

        // Draw Tile
        if(map[y][x]===1){
          // Wall
          ctx.fillStyle = "#333";
          ctx.fillRect(sx,sy,TILE_SIZE,TILE_SIZE);
          // outline
          ctx.strokeStyle = "#1a1a1a";
          ctx.strokeRect(sx,sy,TILE_SIZE,TILE_SIZE);
        } else {
          // Floor
          ctx.fillStyle = "#0a0a0a";
          ctx.fillRect(sx,sy,TILE_SIZE,TILE_SIZE);
          
          // Stains
          const st = stains.find(s=>s.x===x && s.y===y);
          if(st){
            ctx.fillStyle = `rgba(${120+(Math.random()*40)}, 0, ${40+(Math.random()*40)}, 0.4)`;
            ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
          }
        }
        ctx.restore();
      }
    }

    // 4. Draw Objects (Chests/Offerings/Exit)
    const drawObj = (ox, oy, color, shape) => {
       const dist = Math.hypot(ox+0.5 - player.x, oy+0.5 - player.y);
       if(dist > viewRadius && !(pulse.active && Math.abs(dist-pulse.t)<1.5)) return;
       
       const sx = ox*TILE_SIZE;
       const sy = oy*TILE_SIZE;
       ctx.fillStyle = color;
       if(shape==="box") ctx.fillRect(sx+4, sy+4, 8, 8);
       else if(shape==="circle") {
         ctx.beginPath(); ctx.arc(sx+8, sy+8, 4, 0, Math.PI*2); ctx.fill();
       }
       else if(shape==="diamond") {
         ctx.beginPath(); 
         ctx.moveTo(sx+8, sy+2); ctx.lineTo(sx+14, sy+8); 
         ctx.lineTo(sx+8, sy+14); ctx.lineTo(sx+2, sy+8); 
         ctx.fill();
       }
    };

    // Chests (Blue/Cyan)
    chests.forEach(c => {
      if(!c.opened) drawObj(c.x, c.y, "#4488aa", "box");
    });

    // Offerings (Gold/Green based on mission)
    offerings.forEach(o => {
      if(!o.collected) drawObj(o.x, o.y, mission.type==="FOLLOW_ORDER" ? ["#f00","#0f0","#00f"][o.order-1] : "#ddcc44", "circle");
    });

    // Exit (White Diamond if unlocked, Red if locked)
    if(exit){
      drawObj(exit.x, exit.y, exitLocked ? "#550000" : "#ffffff", "diamond");
    }

    // 5. Draw Enemy
    if(enemy.active){
      const dist = Math.hypot(enemy.x-player.x, enemy.y-player.y);
      if(dist < viewRadius + 1.5){
        const sx = enemy.x * TILE_SIZE - 8; // center sprite
        const sy = enemy.y * TILE_SIZE - 8;
        // jitter effect
        const jx = (Math.random()-0.5)*2;
        const jy = (Math.random()-0.5)*2;
        ctx.drawImage(monsterSprite, sx+jx, sy+jy);
      }
    }

    // 6. Draw Player
    ctx.fillStyle = "#eee";
    ctx.fillRect(player.x*TILE_SIZE - 2, player.y*TILE_SIZE - 2, 4, 4);

    // 7. Overlays
    // Flash
    if(flash.active && flash.img){
      ctx.globalAlpha = flash.alpha * 0.85;
      ctx.drawImage(flash.img, 0, 0, canvas.width, canvas.height);
      ctx.globalAlpha = 1;
    }

    // Noise (Anxiety)
    drawNoiseOverlay(globalAnxiety);

    // Messages
    ctx.font = "14px VT323";
    messages.forEach(m => {
      ctx.fillStyle = m.color;
      ctx.globalAlpha = Math.min(1, m.life/20);
      ctx.fillText(m.text, m.x, m.y);
    });
    ctx.globalAlpha = 1;

    // Active Mission / Prompt UI
    if(prompt.active){
      ctx.fillStyle = "rgba(0,0,0,0.85)";
      ctx.fillRect(20, 160, 280, 70);
      ctx.strokeStyle = "#ccffcc";
      ctx.strokeRect(20, 160, 280, 70);
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.fillText(prompt.text, 160, 180);
      ctx.fillStyle = "#aaa";
      ctx.fillText(prompt.a, 160, 200);
      ctx.fillText(prompt.b, 160, 215);
      
      // Timer bar
      ctx.fillStyle = "#f00";
      ctx.fillRect(22, 226, (prompt.timer/6.5)*276, 2);
    } 
    else if(mission.active){
      // small mission HUD
      ctx.textAlign = "left";
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(5, 5, 140, 45);
      ctx.fillStyle = "#ccffcc";
      ctx.fillText(mission.title, 10, 20);
      
      // Progress bar or text
      const pct = clamp(mission.progress / mission.goal, 0, 1);
      ctx.fillStyle = "#444";
      ctx.fillRect(10, 28, 100, 4);
      ctx.fillStyle = "#ccffcc";
      ctx.fillRect(10, 28, 100*pct, 4);
      
      // Hint text lines
      const lines = mission.desc.split('\n');
      if(lines[1]){
         ctx.fillStyle = "#aaa";
         ctx.fillText(lines[1], 10, 42);
      }
    }
  }

  // ===== LOOP =====
  function loop(){
    if(gameStarted){
      update();
      render();
    }
    requestAnimationFrame(loop);
  }

  function startGame(){
    if(gameStarted) return;
    startOverlay.style.display = 'none';
    ensureAudioRunning();
    generateLevel();
    gameStarted = true;
    loop();
  }

})();
</script>
</body>
</html>

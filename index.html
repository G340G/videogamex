<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>ENTROPY.DAT</title>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#050505;
    --fg:#cfe2da;
    --ui:#ccffcc;
    --danger:#ff3355;
    --dim:rgba(204,255,204,.25);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:'VT323',monospace;overflow:hidden;}
  #wrap{height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;user-select:none;}
  #crt{
    position:relative;width:640px;height:480px;background:#000;
    border:1px solid #2a2a2a; box-shadow:0 0 25px rgba(0,0,0,.85);
  }
  canvas{width:100%;height:100%;display:block;image-rendering:pixelated;background:#000;}
  .scanlines{
    position:absolute;inset:0;z-index:10;pointer-events:none;
    background:linear-gradient(to bottom,
      rgba(255,255,255,0),
      rgba(255,255,255,0) 50%,
      rgba(0,0,0,.22) 50%,
      rgba(0,0,0,.22)
    );
    background-size:100% 4px;
    mix-blend-mode:overlay;
  }
  #crt::after{
    content:""; position:absolute; inset:0; z-index:10; pointer-events:none;
    background:rgba(18,16,16,.10); opacity:0;
    animation:flicker .14s infinite;
  }
  @keyframes flicker{0%{opacity:.02}50%{opacity:.06}100%{opacity:.02}}

  /* compact HUD */
  #hud{
    position:absolute; top:6px; left:6px; z-index:20; pointer-events:none;
    color:var(--ui); text-shadow:0 0 5px rgba(204,255,204,.6);
    font-size:1.05rem; line-height:1.05;
    background:rgba(0,0,0,0.33);
    border:1px solid var(--dim);
    border-radius:4px;
    padding:6px 8px;
    max-width:180px;
  }
  #hud .dim{opacity:.7}
  #hud .red{color:var(--danger);text-shadow:0 0 5px rgba(255,51,85,.65)}
  .bar{height:4px;background:rgba(255,255,255,.12);margin-top:4px;position:relative;overflow:hidden}
  .bar > i{display:block;height:100%;width:50%;background:rgba(204,255,204,.9)}
  .bar.red > i{background:rgba(255,51,85,.85)}

  /* start overlay */
  #overlay{
    position:absolute; inset:0; z-index:30;
    display:grid; place-items:center;
    background:radial-gradient(circle at center, rgba(0,0,0,.30), rgba(0,0,0,.93));
  }
  .panel{
    width:min(560px,92%); padding:14px 14px 10px;
    border:1px solid rgba(204,255,204,.22);
    border-radius:6px;
    background:rgba(0,0,0,.55);
    box-shadow:0 0 18px rgba(0,0,0,.6);
    color:var(--ui);
    text-shadow:0 0 8px rgba(204,255,204,.25);
  }
  .title{font-size:3.4rem;letter-spacing:2px;text-align:center;margin:0 0 10px}
  .sub{font-size:1.4rem;text-align:center;opacity:.9;margin:6px 0}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin:10px 0}
  input,select,button{
    font-family:'VT323'; font-size:1.25rem; padding:8px 10px;
    background:#000; color:var(--fg);
    border:1px solid rgba(255,255,255,.18);
    outline:none;
  }
  input{min-width:240px}
  button{cursor:pointer;border-color:rgba(204,255,204,.35);color:var(--ui)}
  button:hover{filter:brightness(1.15)}
  .tiny{opacity:.65;text-align:center;font-size:1.05rem}

  .hint{
    text-align:center; opacity:.6; font-size:1.2rem;
  }
</style>
</head>
<body>
<div id="wrap">
  <div id="crt">
    <div class="scanlines"></div>

    <div id="hud">
      <div id="hName">NAME: ???</div>
      <div id="hRole" class="dim">ROLE: ???</div>
      <div id="hDiff" class="dim">DIFF: ???</div>
      <div id="hRun" class="dim">RUN: OFF</div>

      <div style="margin-top:6px">
        <div class="dim">OXYGEN</div>
        <div class="bar red"><i id="hOxy"></i></div>
      </div>

      <div style="margin-top:6px">
        <div class="dim">MISSION</div>
        <div id="hMission" class="dim">LOCKED</div>
        <div class="bar"><i id="hMis"></i></div>
      </div>

      <div style="margin-top:6px" class="dim">
        <div id="hLoot">CHESTS 0/0</div>
        <div id="hOff">OFFERINGS 0/0</div>
        <div id="hAtk" class="dim">ACTION: READY</div>
      </div>
    </div>

    <canvas id="game" width="320" height="240"></canvas>

    <div id="overlay">
      <div class="panel">
        <div class="title">ENTROPY.DAT</div>
        <div class="sub">IDENTITY REQUIRED</div>

        <div class="row">
          <input id="nameInput" type="text" autocomplete="off" spellcheck="false" placeholder="PROTAGONIST NAME">
          <select id="roleInput">
            <option value="thief">THIEF</option>
            <option value="killer">KILLER</option>
            <option value="butcher">BUTCHER</option>
          </select>
        </div>

        <div class="row">
          <button id="startBtn" type="button">INITIALIZE</button>
        </div>

        <div class="tiny">
          WASD / Arrows · Shift = run (louder) · E = Signal Pulse · Space = Action · 1/2 respond<br/>
          Chests unlock missions. Finish mission to unseal exit. Oxygen lasts &gt; 60s.
        </div>
      </div>
    </div>
  </div>

  <div class="hint">
    Run makes you easier to track. Killing creates hallucinations. The maze remembers your name.
  </div>
</div>

<script>
(() => {
  /* ============================================================
     CONFIG
  ============================================================ */
  const W=320,H=240;
  const TILE=16;
  const COLS=20, ROWS=15;

  const TOTAL_OFFERINGS=3;
  const CHESTS_PER_LEVEL=3;
  const STAINS=8;

  const BASE_FOV=6.1, MIN_FOV=4.0, MAX_FOV=7.2;

  // Movement + collision (no corner sticking)
  const PLAYER_RADIUS=0.28;
  const ACCEL=14.0;
  const FRICTION=0.80;
  const MAX_WALK=2.15;
  const MAX_RUN=3.10;

  // Oxygen pacing (>= 60s)
  const BASE_OXYGEN=92;       // seconds (walking)
  const RUN_OXY_MULT=1.55;
  const OXY_TANKS=3;
  const OXY_TANK_GAIN=35;

  // Combat pacing
  const ACTION_CD_BASE=0.55;
  const ACTION_NOISE=1.0;

  // Hallucination after kill
  const HALLU_GAIN_MIN=26;
  const HALLU_GAIN_MAX=40;
  const HALLU_DECAY_PER_SEC=1.2;

  // Colors / vibe
  const PAL={
    wall:"#32343d",
    floor:"#09090b",
    fog:"#000000",
    ui:"#ccffcc",
    danger:"#ff3355",
    white:"#f1f1f1"
  };

  /* ============================================================
     DOM
  ============================================================ */
  const canvas=document.getElementById("game");
  const ctx=canvas.getContext("2d",{alpha:false});

  const overlay=document.getElementById("overlay");
  const startBtn=document.getElementById("startBtn");
  const nameInput=document.getElementById("nameInput");
  const roleInput=document.getElementById("roleInput");

  const hName=document.getElementById("hName");
  const hRole=document.getElementById("hRole");
  const hDiff=document.getElementById("hDiff");
  const hRun=document.getElementById("hRun");
  const hOxy=document.getElementById("hOxy");
  const hMission=document.getElementById("hMission");
  const hMis=document.getElementById("hMis");
  const hLoot=document.getElementById("hLoot");
  const hOff=document.getElementById("hOff");
  const hAtk=document.getElementById("hAtk");

  /* ============================================================
     STATE
  ============================================================ */
  let keys={};
  let started=false;

  let map=[];
  let stains=[];
  let offerings=[];
  let chests=[];
  let oxyTanks=[];
  let exit=null;
  let exitLocked=true;

  let messages=[];
  let prompt={active:false,text:"",a:"",b:"",onChoose:null,timer:0};

  let mission={
    active:false, completed:false,
    title:"", desc:"",
    type:"", progress:0, goal:1, extra:null
  };

  const hero={
    name:"UNKNOWN",
    role:"thief",
    x:1.5,y:1.5,
    vx:0,vy:0,
    oxygen:BASE_OXYGEN,
    oxygenMax:BASE_OXYGEN,
    sanity:100,
    panic:0,
    hitCD:0,
    actionCD:0,
    animT:0,
    hallucination:0, // seconds
    kills:0
  };

  const run={
    anxiety:0,
    diffIndex:0,
    diffLabel:"",
    monstersCount:1,
    aggression:1.0,
    oxygenDrain:1.0,
    seedSalt:(Math.random()*1e9)|0
  };

  // monsters are non-solid “danger zones” (you can run through with risk)
  let monsters=[]; // {x,y,hp,stun,deadTimer,respawnAt,stepCd,target,lastSeen,kind}

  /* ============================================================
     TEXT + LORE
  ============================================================ */
  const crypticPhrases=[
    "IT KNOWS","BEHIND YOU","NULL REFERENCE","WHERE AM I","DONT STOP","STATIC...","1997",
    "DE-SYNC","LOST SIGNAL","FRAME DROP","NO CLIP","DOOR IS NOT A DOOR",
    "EYES IN THE FOG","THE MAZE REMEMBERS","YOU ARE DATA","THE FLOOR IS BREATHING",
    "COPY OF A COPY","SHE IS STILL HERE","TAPE HISS","SIGNAL BLEED"
  ];

  const loreBits={
    kidnapped:[
      "They took her from a parking lot under a dead streetlight.",
      "A van that smelled like wet carpet and iron.",
      "You heard the tape recorder start. You never heard it stop.",
      "They said your name like they owned it."
    ],
    thief:[
      "You stole keys you didn't understand.",
      "You can pick locks, but not guilt.",
      "Every door you open remembers your fingerprints."
    ],
    killer:[
      "You did it clean. Too clean.",
      "There are faces in the fog that look like your work.",
      "You keep rehearsing apologies you will never speak."
    ],
    butcher:[
      "You know the weight of meat when it stops being alive.",
      "Your hands remember cuts your mind refuses.",
      "The maze smells familiar."
    ],
    endings:[
      "The exit is not escape. It's upload.",
      "Something will wear your voice after you leave.",
      "Your breath becomes geometry."
    ]
  };

  function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

  function generateLore(){
    const name=hero.name.toUpperCase();
    return `${name}. ${pick(loreBits.kidnapped)} ${pick(loreBits[hero.role])} ${pick(loreBits.endings)}`;
  }

  const lorePrompts=[
    {
      text:(n)=>`A smear spells: "${n}, DO YOU WANT TO BE SEEN?"`,
      a:"1) YES (clearer, louder)",
      b:"2) NO  (safer, dimmer)",
      choose:(c)=>{
        if(c===1){ run.anxiety=Math.max(run.anxiety,10); run.aggression+=0.10; pushMessage("YOU ARE VISIBLE", PAL.danger); }
        else { run.aggression=Math.max(0.9, run.aggression-0.08); pushMessage("YOU ARE MISSING", PAL.ui); }
      }
    },
    {
      text:(n)=>`The CRT whispers: "${n}, SACRIFICE OXYGEN FOR SPEED?"`,
      a:"1) ACCEPT (faster, drains more)",
      b:"2) REFUSE (slower, calmer)",
      choose:(c)=>{
        if(c===1){ run.oxygenDrain*=1.18; pushMessage("HUNGER ENGINE", PAL.danger); }
        else { run.oxygenDrain=Math.max(0.85, run.oxygenDrain*0.92); run.aggression+=0.06; pushMessage("SLOW MERCY", PAL.ui); }
      }
    },
    {
      text:(n)=>`A radio click: "${n}. WHICH PART OF YOU IS REAL?"`,
      a:"1) HANDS",
      b:"2) VOICE",
      choose:(c)=>{
        if(c===1){ hero.hitCD=Math.max(hero.hitCD,0.6); pushMessage("HANDS REMEMBER", "#fff"); }
        else { run.anxiety=Math.max(run.anxiety,14); pushMessage("VOICE LIES", PAL.danger); }
      }
    }
  ];

  /* ============================================================
     INPUT (typing does not start the game)
  ============================================================ */
  window.addEventListener("keydown",(e)=>{
    keys[e.code]=true;
    if(!started) return;

    if(e.code==="KeyE") triggerPulse();
    if(e.code==="Space") tryAction();

    if(prompt.active){
      if(e.code==="Digit1"||e.code==="Numpad1"||e.code==="KeyY") choosePrompt(1);
      if(e.code==="Digit2"||e.code==="Numpad2"||e.code==="KeyN") choosePrompt(2);
    }
  },{passive:true});
  window.addEventListener("keyup",(e)=>keys[e.code]=false,{passive:true});

  startBtn.addEventListener("pointerdown",(e)=>{
    e.preventDefault(); e.stopPropagation();
    startGame();
  });
  overlay.addEventListener("pointerdown",(e)=>{ e.stopPropagation(); });

  /* ============================================================
     AUDIO (organic, scary, reactive)
  ============================================================ */
  let audio=null;

  function initAudio(){
    if(audio) return;
    const AC=window.AudioContext||window.webkitAudioContext;
    const ac=new AC();

    const master=ac.createGain();
    master.gain.value=0.75;
    master.connect(ac.destination);

    // pink-ish noise buffer
    const noiseBuf=ac.createBuffer(1, ac.sampleRate*2, ac.sampleRate);
    {
      const d=noiseBuf.getChannelData(0);
      let last=0;
      for(let i=0;i<d.length;i++){
        last=0.965*last + 0.035*(Math.random()*2-1);
        d[i]=last;
      }
    }

    const wind=ac.createBufferSource();
    wind.buffer=noiseBuf; wind.loop=true;
    const windLP=ac.createBiquadFilter();
    windLP.type="lowpass"; windLP.frequency.value=240;
    const windGain=ac.createGain(); windGain.gain.value=0.04;
    wind.connect(windLP); windLP.connect(windGain); windGain.connect(master);
    wind.start();

    const radio=ac.createBufferSource();
    radio.buffer=noiseBuf; radio.loop=true;
    const radioBP=ac.createBiquadFilter();
    radioBP.type="bandpass"; radioBP.frequency.value=1200; radioBP.Q.value=0.9;
    const radioGain=ac.createGain(); radioGain.gain.value=0.015;
    radio.connect(radioBP); radioBP.connect(radioGain); radioGain.connect(master);
    radio.start();

    // drone (two oscillators + slow FM)
    const o1=ac.createOscillator(); o1.type="sine"; o1.frequency.value=46;
    const o2=ac.createOscillator(); o2.type="triangle"; o2.frequency.value=69;

    const fm=ac.createOscillator(); fm.type="sine"; fm.frequency.value=0.11;
    const fmGain=ac.createGain(); fmGain.gain.value=11;
    fm.connect(fmGain); fmGain.connect(o1.frequency);

    const droneLP=ac.createBiquadFilter();
    droneLP.type="lowpass"; droneLP.frequency.value=600;
    const droneGain=ac.createGain(); droneGain.gain.value=0.022;

    const mix=ac.createGain(); mix.gain.value=1;
    o1.connect(mix); o2.connect(mix);
    mix.connect(droneLP); droneLP.connect(droneGain); droneGain.connect(master);

    o1.start(); o2.start(); fm.start();

    // short “blip” event
    function blip(intensity=0.4){
      const t=ac.currentTime;
      const osc=ac.createOscillator();
      osc.type=Math.random()<0.5?"square":"triangle";
      osc.frequency.value=80+Math.random()*2200;

      const bp=ac.createBiquadFilter();
      bp.type="bandpass"; bp.frequency.value=400+Math.random()*3200; bp.Q.value=7+Math.random()*5;

      const g=ac.createGain();
      g.gain.setValueAtTime(0,t);
      g.gain.linearRampToValueAtTime(0.08*intensity, t+0.003);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);

      osc.connect(bp); bp.connect(g); g.connect(master);
      osc.start(t); osc.stop(t+0.12);
    }

    // low throb
    function throb(intensity=0.4){
      const t=ac.currentTime;
      const osc=ac.createOscillator();
      osc.type="sine"; osc.frequency.value=24+Math.random()*18;
      const g=ac.createGain();
      g.gain.setValueAtTime(0,t);
      g.gain.linearRampToValueAtTime(0.05*intensity, t+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.35);
      osc.connect(g); g.connect(master);
      osc.start(t); osc.stop(t+0.36);
    }

    function mutate(){
      const t=ac.currentTime;
      const fear=audio?.fear ?? 0;
      const hallu=audio?.hallu ?? 0;

      radioBP.frequency.setTargetAtTime(600 + Math.random()*3200, t, 1.4);
      radioBP.Q.setTargetAtTime(0.8 + fear*9 + hallu*3 + Math.random()*1.2, t, 0.9);
      radioGain.gain.setTargetAtTime(0.010 + 0.03*Math.random() + fear*0.08 + hallu*0.06, t, 0.25);

      windLP.frequency.setTargetAtTime(110 + Math.random()*360, t, 2.2);
      windGain.gain.setTargetAtTime(0.03 + 0.06*Math.random() + fear*0.08, t, 0.6);

      droneLP.frequency.setTargetAtTime(240 + Math.random()*1100 + fear*600 + hallu*350, t, 1.7);
      droneGain.gain.setTargetAtTime(0.016 + 0.03*Math.random() + fear*0.08 + hallu*0.04, t, 1.1);

      o1.frequency.setTargetAtTime(34 + Math.random()*44 + hallu*8, t, 1.5);
      o2.frequency.setTargetAtTime(50 + Math.random()*78 + hallu*12, t, 1.8);

      // detune spikes during hallucination
      if(hallu>0.25 && Math.random()<0.18){
        o1.detune.setTargetAtTime((Math.random()<0.5?-1:1)*(60+Math.random()*200), t, 0.25);
        setTimeout(()=>o1.detune.setTargetAtTime(0, ac.currentTime, 0.7), 600+Math.random()*1400);
      }

      if(Math.random() < 0.14 + fear*0.25) blip(0.25 + Math.random()*(0.4+fear));
      if(Math.random() < 0.10 + fear*0.18 + hallu*0.12) throb(0.25 + fear*0.9 + hallu*0.6);

      setTimeout(mutate, 800 + Math.random()*1600);
    }

    function eventTick(){
      const fear=audio?.fear ?? 0;
      const hallu=audio?.hallu ?? 0;
      if(Math.random() < 0.09 + fear*0.25 + hallu*0.2) blip(0.15 + Math.random()*(0.35+fear+hallu));
      setTimeout(eventTick, 260 + Math.random()*(950 - fear*450));
    }

    audio={
      ac,
      fear:0,
      hallu:0,
      blip,
      setFear(f){ audio.fear=f; },
      setHallu(h){ audio.hallu=h; }
    };

    setTimeout(mutate, 600);
    setTimeout(eventTick, 900);
  }

  async function ensureAudioRunning(){
    initAudio();
    if(audio?.ac?.state==="suspended"){
      try{ await audio.ac.resume(); }catch{}
    }
  }

  /* ============================================================
     HELPERS
  ============================================================ */
  const clamp=(v,a,b)=> v<a?a : v>b?b : v;
  const inBounds=(x,y)=> x>=0&&y>=0&&x<COLS&&y<ROWS;
  const isFloor=(x,y)=> inBounds(x,y) && map[y][x]===0;

  function pushMessage(text,color="#fff"){
    messages.push({
      text,
      x:10+Math.random()*(W-20),
      y:20+Math.random()*(H-20),
      life:70,
      color
    });
  }
  function triggerMessage(text=null){
    if(Math.random()>0.38 && !text) return;
    const phrase=text||crypticPhrases[(Math.random()*crypticPhrases.length)|0];
    pushMessage(phrase, Math.random()>0.5?PAL.danger:"#fff");
  }

  function randomFloorFar(px,py,manh){
    for(let i=0;i<900;i++){
      const x=(Math.random()*COLS)|0;
      const y=(Math.random()*ROWS)|0;
      if(!isFloor(x,y)) continue;
      if(Math.abs(x-px)+Math.abs(y-py)<manh) continue;
      return {x,y};
    }
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      if(isFloor(x,y) && Math.abs(x-px)+Math.abs(y-py)>=manh) return {x,y};
    }
    return {x:1,y:1};
  }

  /* ============================================================
     BRAIDED MAZE
  ============================================================ */
  function generateBraidedMaze(){
    map=Array(ROWS).fill(0).map(()=>Array(COLS).fill(1));
    const stack=[{x:1,y:1}];
    map[1][1]=0;

    while(stack.length){
      const c=stack[stack.length-1];
      const dirs=[[2,0],[-2,0],[0,2],[0,-2]].sort(()=>Math.random()-0.5);
      let carved=false;
      for(const[dx,dy] of dirs){
        const nx=c.x+dx, ny=c.y+dy;
        if(nx>0&&ny>0&&nx<COLS-1&&ny<ROWS-1&&map[ny][nx]===1){
          map[ny][nx]=0;
          map[c.y+dy/2][c.x+dx/2]=0;
          stack.push({x:nx,y:ny});
          carved=true; break;
        }
      }
      if(!carved) stack.pop();
    }

    // braid dead ends
    for(let y=1;y<ROWS-1;y++){
      for(let x=1;x<COLS-1;x++){
        if(map[y][x]!==0) continue;
        let exits=0;
        const neigh=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const[dX,dY] of neigh){
          if(map[y+dY][x+dX]===0) exits++;
        }
        if(exits===1 && Math.random()<0.62){
          const dirs=neigh.sort(()=>Math.random()-0.5);
          for(const[dX,dY] of dirs){
            if(map[y+dY][x+dX]===1){
              map[y+dY][x+dX]=0;
              break;
            }
          }
        }
      }
    }

    // extra loops
    for(let i=0;i<16;i++){
      const x=1+((Math.random()*(COLS-2))|0);
      const y=1+((Math.random()*(ROWS-2))|0);
      if(map[y][x]===1 && Math.random()<0.5) map[y][x]=0;
    }
  }

  /* ============================================================
     COLLISION (circle vs tiles)
  ============================================================ */
  function resolveCircleGrid(px,py,r){
    let x=px,y=py;
    const minX=Math.floor(x-1), maxX=Math.floor(x+1);
    const minY=Math.floor(y-1), maxY=Math.floor(y+1);

    for(let ty=minY; ty<=maxY; ty++){
      for(let tx=minX; tx<=maxX; tx++){
        if(!inBounds(tx,ty) || map[ty][tx]===1){
          const cx=clamp(x, tx, tx+1);
          const cy=clamp(y, ty, ty+1);
          const dx=x-cx, dy=y-cy;
          const d=Math.hypot(dx,dy);
          if(d<r){
            const push=(r-d)/(d||1);
            x += dx*push;
            y += dy*push;
          }
        }
      }
    }
    return {x,y};
  }

  /* ============================================================
     OBJECTIVES / PULSE
  ============================================================ */
  let pulse={active:false, t:0, ring:0};

  function nearestObjective(){
    let best=null, bestD=1e9;
    for(const c of chests){
      if(c.opened) continue;
      const d=Math.hypot((c.x+0.5)-hero.x,(c.y+0.5)-hero.y);
      if(d<bestD){ bestD=d; best={x:c.x,y:c.y}; }
    }
    if(best) return best;

    for(const o of offerings){
      if(o.collected) continue;
      const d=Math.hypot((o.x+0.5)-hero.x,(o.y+0.5)-hero.y);
      if(d<bestD){ bestD=d; best={x:o.x,y:o.y}; }
    }
    if(!best && exit) best={x:exit.x,y:exit.y};
    return best;
  }

  function triggerPulse(){
    if(!started) return;
    if(pulse.active) return;
    const t=nearestObjective();
    if(!t) return;
    pulse.active=true; pulse.t=0; pulse.ring=0;
    run.anxiety=Math.max(run.anxiety,10);
    audio?.blip?.(1.0);
    pushMessage("ECHO PULSE", "#fff");

    if(mission.active && mission.type==="ECHO_COUNT"){
      mission.extra.used++;
      if(mission.extra.used > mission.extra.max){
        mission.extra.used=0;
        run.anxiety=Math.max(run.anxiety,16);
        pushMessage("ECHO OVERFLOW", PAL.danger);
      }
    }
  }

  /* ============================================================
     PROMPTS
  ============================================================ */
  function showPrompt(p){
    if(prompt.active) return;
    prompt.active=true;
    prompt.text=p.text(hero.name.toUpperCase());
    prompt.a=p.a; prompt.b=p.b;
    prompt.onChoose=p.choose;
    prompt.timer=6.6;
    pushMessage("INPUT REQUIRED", PAL.ui);
    run.anxiety=Math.max(run.anxiety,10);
  }

  function choosePrompt(choice){
    if(!prompt.active) return;
    const fn=prompt.onChoose;
    prompt.active=false;
    if(fn) fn(choice);
    audio?.blip?.(0.9);
  }

  /* ============================================================
     MISSIONS
  ============================================================ */
  function setMission(m){
    mission.active=true;
    mission.completed=false;
    mission.title=m.title;
    mission.desc=m.desc;
    mission.type=m.type;
    mission.progress=0;
    mission.goal=m.goal ?? 1;
    mission.extra=m.extra ?? null;

    exitLocked=true;
    pushMessage(`${hero.name.toUpperCase()}: NEW MISSION`, PAL.ui);
    triggerMessage("NEW TASK LOADED");
  }

  function completeMission(){
    mission.completed=true;
    mission.active=false;
    exitLocked=false;
    triggerMessage("TASK COMPLETE");
    triggerMessage("EXIT UNSEALED");
    audio?.blip?.(1.0);
    run.anxiety=Math.max(0, run.anxiety-4);
  }

  function generateRandomMission(){
    const d=run.diffIndex;
    const types=["STILLNESS","NO_RUN","STAIN_TOUCH","ECHO_COUNT","FOLLOW_ORDER"];
    const t=types[(Math.random()*types.length)|0];

    if(t==="STILLNESS"){
      const seconds=2.2 + Math.random()*2.3 + d*0.35;
      return { type:"STILLNESS", title:"STILLNESS RITUAL",
        desc:`Stand still near a stain for ${seconds.toFixed(1)}s.\n(Don't move.)`,
        goal:seconds
      };
    }

    if(t==="NO_RUN"){
      const time=9 + ((Math.random()*9)|0) + d*2;
      return { type:"NO_RUN", title:"SILENT WALK",
        desc:`Survive ${time}s without sprinting.\n(Shift forbidden.)`,
        goal:time
      };
    }

    if(t==="STAIN_TOUCH"){
      const count=2 + ((Math.random()*2)|0) + (d>1?1:0);
      return { type:"STAIN_TOUCH", title:"TOUCH THE CORRUPTION",
        desc:`Step into ${count} different stains.\n(Each counts once.)`,
        goal:count,
        extra:{touched:new Set()}
      };
    }

    if(t==="ECHO_COUNT"){
      const pulses=2 + ((Math.random()*2)|0) + (d>2?1:0);
      return { type:"ECHO_COUNT", title:"ECHO TEST",
        desc:`Use Signal Pulse (E) exactly ${pulses} times.\n(Too many resets.)`,
        goal:pulses,
        extra:{used:0,max:pulses}
      };
    }

    // FOLLOW_ORDER
    const order=[1,2,3].sort(()=>Math.random()-0.5);
    offerings.forEach((o,i)=>o.order=order[i]);
    return { type:"FOLLOW_ORDER", title:"SEQUENCE OF OFFERINGS",
      desc:`Collect offerings in correct sequence.\n(Colors indicate order.)`,
      goal:TOTAL_OFFERINGS,
      extra:{needed:1}
    };
  }

  function updateMission(dt, moving, sprinting){
    if(!mission.active) return;

    if(mission.type==="STILLNESS"){
      const near=stains.some(s=>Math.hypot((s.x+0.5)-hero.x,(s.y+0.5)-hero.y)<2.0);
      if(!moving && near) mission.progress += dt;
      else mission.progress = Math.max(0, mission.progress - dt*0.9);
      if(mission.progress >= mission.goal) completeMission();
      return;
    }

    if(mission.type==="NO_RUN"){
      if(sprinting){
        mission.progress = Math.max(0, mission.progress - dt*2.2);
        if(Math.random()<0.02) triggerMessage("TOO LOUD");
        run.anxiety=Math.max(run.anxiety,12);
      } else mission.progress += dt;
      if(mission.progress >= mission.goal) completeMission();
      return;
    }

    if(mission.type==="STAIN_TOUCH"){
      for(const s of stains){
        if(Math.hypot((s.x+0.5)-hero.x,(s.y+0.5)-hero.y)<0.95){
          mission.extra.touched.add(`${s.x},${s.y}`);
        }
      }
      mission.progress = mission.extra.touched.size;
      if(mission.progress >= mission.goal) completeMission();
      return;
    }

    if(mission.type==="ECHO_COUNT"){
      mission.progress = mission.extra.used;
      if(mission.progress >= mission.goal) completeMission();
      return;
    }

    if(mission.type==="FOLLOW_ORDER"){
      mission.progress = collectedCount;
      return;
    }
  }

  /* ============================================================
     FLASH IMAGES / DISTORTION (procedural, hooks for your assets)
  ============================================================ */
  // Later you can add:
  // const FLASH_IMAGES = ["assets/your1.png","assets/your2.png"];
  // const FACE_IMAGES = ["assets/face1.png","assets/face2.png"];
  // and load them. For now, procedural.

  function generateCreepyImage(kind="face"){
    const c=document.createElement("canvas");
    c.width=160; c.height=120;
    const g=c.getContext("2d");
    g.fillStyle="#000"; g.fillRect(0,0,c.width,c.height);

    // base noise
    for(let i=0;i<3200;i++){
      const x=(Math.random()*c.width)|0;
      const y=(Math.random()*c.height)|0;
      const v=(Math.random()*60)|0;
      g.fillStyle=`rgb(${v},${v},${v})`;
      g.fillRect(x,y,1,1);
    }

    // red smears
    g.globalAlpha=0.25;
    for(let i=0;i<10;i++){
      g.fillStyle = Math.random()<0.5 ? "rgb(140,0,30)" : "rgb(80,0,120)";
      g.fillRect((Math.random()*c.width)|0, (Math.random()*c.height)|0, 10+(Math.random()*70|0), 2+(Math.random()*10|0));
    }
    g.globalAlpha=1;

    if(kind==="face"){
      const cx=c.width/2 + (Math.random()*18-9);
      const cy=c.height/2 + (Math.random()*12-6);
      const eyeY=cy-10 + Math.random()*6;
      const eyeDX=28 + Math.random()*12;

      g.fillStyle="rgba(255,60,90,0.65)";
      g.fillRect(cx-eyeDX, eyeY, 9, 4);
      g.fillRect(cx+eyeDX-9, eyeY, 9, 4);

      g.fillStyle="rgba(0,0,0,0.9)";
      g.fillRect(cx-eyeDX+4, eyeY+1, 2, 2);
      g.fillRect(cx+eyeDX-6, eyeY+1, 2, 2);

      g.fillStyle="rgba(255,255,255,0.12)";
      g.fillRect(cx-22, cy+14, 44, 3);
    }

    // glitch smear
    g.globalAlpha=0.22;
    for(let i=0;i<7;i++){
      const y=(Math.random()*c.height)|0;
      const dx=(Math.random()*26-13);
      g.drawImage(c, 0, y, c.width, 2, dx, y, c.width, 2);
    }
    g.globalAlpha=1;

    return c;
  }

  const flash={active:false,t:0,dur:0.9,img:null,alpha:0,kind:"face"};
  function triggerFlash(kind="face"){
    flash.active=true;
    flash.t=0;
    flash.dur=0.65+Math.random()*0.8;
    flash.img=generateCreepyImage(kind);
    flash.alpha=0;
    flash.kind=kind;
  }

  /* ============================================================
     MONSTER SPRITE (procedural; hook for your face images later)
  ============================================================ */
  function makeMonsterSprite(){
    const c=document.createElement("canvas");
    c.width=20; c.height=20;
    const g=c.getContext("2d");
    g.clearRect(0,0,20,20);

    g.fillStyle="rgba(30,30,42,0.95)";
    g.fillRect(4,4,12,12);

    g.fillStyle="rgba(255,60,90,0.85)";
    g.fillRect(7,10,2,1);
    g.fillRect(11,10,2,1);

    g.fillStyle="rgba(0,0,0,0.9)";
    g.fillRect(8,13,4,2);

    for(let i=0;i<30;i++){
      const x=(Math.random()*20)|0;
      const y=(Math.random()*20)|0;
      g.fillStyle=Math.random()<0.5?"rgba(255,60,90,0.10)":"rgba(255,255,255,0.08)";
      g.fillRect(x,y,1,1);
    }
    return c;
  }
  const monsterSprite=makeMonsterSprite();

  /* ============================================================
     COMBAT (Space): role-based, effective but costly
  ============================================================ */
  function actionProfile(){
    // range, damage, stagger seconds, oxygenCost, noise, selfFear
    if(hero.role==="thief"){
      return {range:1.25, dmg:8, stagger:0.9, oxy:4, noise:0.7, fear:0.7};
    }
    if(hero.role==="killer"){
      return {range:1.05, dmg:22, stagger:0.5, oxy:10, noise:1.45, fear:1.1};
    }
    // butcher
    return {range:1.55, dmg:12, stagger:1.2, oxy:14, noise:1.25, fear:1.0, pull:0.75};
  }

  function tryAction(){
    if(!started) return;
    if(hero.actionCD>0) return;

    const atk=actionProfile();
    if(hero.oxygen < atk.oxy) return;

    hero.oxygen = Math.max(0, hero.oxygen - atk.oxy);
    hero.actionCD = ACTION_CD_BASE + atk.dmg*0.02; // killer has longer CD
    run.anxiety = Math.max(run.anxiety, 8 + atk.noise*6);

    audio?.blip?.(atk.noise);

    let hit=false;

    for(const m of monsters){
      if(m.deadTimer>0) continue;
      const dx=m.x-hero.x, dy=m.y-hero.y;
      const d=Math.max(1e-6, Math.hypot(dx,dy));
      if(d <= atk.range){
        hit=true;
        m.hp -= atk.dmg;
        m.stun = Math.max(m.stun, atk.stagger);
        m.lastSeen = 2.0;

        if(atk.pull){
          m.x += (dx/d) * atk.pull;
          m.y += (dy/d) * atk.pull;
        }

        triggerFlash("face");
        pushMessage("HIT", PAL.danger);

        if(m.hp <= 0){
          banishMonster(m);
        }
      }
    }

    if(!hit){
      // whiff = makes noise anyway
      if(Math.random()<0.18) triggerMessage("MISSED");
    }

    // action makes you “louder”
    for(const m of monsters){
      if(m.deadTimer>0) continue;
      m.alert = Math.min(2.4, (m.alert||0) + atk.noise*0.6);
    }
  }

  function banishMonster(m){
    // Not permanent. It returns.
    m.deadTimer = 10 + Math.random()*10;
    m.hp = m.hpMax; // reset on return
    m.stun = 0;
    m.alert = 0;

    hero.kills++;
    hero.hallucination = Math.min(60, hero.hallucination + (HALLU_GAIN_MIN + Math.random()*(HALLU_GAIN_MAX-HALLU_GAIN_MIN)));
    pushMessage(`${hero.name.toUpperCase()}: WHAT DID YOU DO`, "#fff");
    triggerMessage("IT COMES BACK");
    audio?.blip?.(1.2);
  }

  /* ============================================================
     MONSTERS (AI): non-solid threat; cannot hard-block corridors
  ============================================================ */
  function pickNeighborStep(mx,my,tx,ty){
    const gx=Math.floor(mx), gy=Math.floor(my);
    const opts=[
      {x:gx+1,y:gy},{x:gx-1,y:gy},{x:gx,y:gy+1},{x:gx,y:gy-1}
    ].filter(p=>isFloor(p.x,p.y));
    if(!opts.length) return null;

    let best=opts[0], bestScore=1e9;
    for(const o of opts){
      const d=Math.hypot((o.x+0.5)-tx,(o.y+0.5)-ty);
      const wob=(Math.random()-0.5)*0.35;
      const score=d+wob;
      if(score<bestScore){ bestScore=score; best=o; }
    }
    return best;
  }

  function spawnMonsters(){
    monsters=[];
    for(let i=0;i<run.monstersCount;i++){
      const r=randomFloorFar(1,1, 12+i*2);
      const baseHp = 42 + run.diffIndex*10;
      monsters.push({
        x:r.x+0.5, y:r.y+0.5,
        hpMax:baseHp,
        hp:baseHp,
        stun:0,
        deadTimer:0,
        stepCd:0,
        target:null,
        lastSeen:0,
        alert:0,
        kind:(Math.random()<0.5?"stalker":"hunger")
      });
    }
  }

  function updateMonsters(dt){
    let closest=999;

    for(const m of monsters){
      if(m.deadTimer>0){
        m.deadTimer = Math.max(0, m.deadTimer-dt);
        if(m.deadTimer<=0){
          // respawn far
          const r=randomFloorFar((hero.x|0),(hero.y|0), 12+run.diffIndex*2);
          m.x=r.x+0.5; m.y=r.y+0.5;
          m.hp=m.hpMax;
          m.alert=0;
          triggerMessage("RETURN");
        }
        continue;
      }

      if(m.stun>0){
        m.stun = Math.max(0, m.stun-dt);
        continue;
      }

      const dx=hero.x-m.x, dy=hero.y-m.y;
      const dist=Math.max(1e-6, Math.hypot(dx,dy));
      closest=Math.min(closest, dist);

      const sprinting=!!keys.ShiftLeft;
      const hearRadius = (sprinting ? 7.8 : 4.8) + (m.alert||0);

      // hallucinations make the world “noisier”
      const halluBoost = hero.hallucination>0 ? 1.0 : 0.0;

      let tx=m.x, ty=m.y;

      if(dist < hearRadius){
        m.lastSeen = 1.6 + halluBoost*0.7;
        tx=hero.x; ty=hero.y;
      } else if(m.lastSeen>0){
        m.lastSeen = Math.max(0, m.lastSeen-dt);
        tx = m.x + (dx/dist)*1.0;
        ty = m.y + (dy/dist)*1.0;
      } else {
        // drift to stains (creepy)
        const s=stains[(Math.random()*stains.length)|0];
        tx=s.x+0.5; ty=s.y+0.5;
      }

      m.stepCd -= dt;
      if(m.stepCd<=0 || !m.target){
        m.stepCd = 0.14 + Math.random()*0.20;
        const step=pickNeighborStep(m.x,m.y,tx,ty);
        if(step) m.target=step;
      }

      const speed=(0.85 + run.diffIndex*0.12) * run.aggression * (m.kind==="hunger"?1.06:1.0);
      if(m.target){
        const cx=m.target.x+0.5, cy=m.target.y+0.5;
        const mdx=cx-m.x, mdy=cy-m.y;
        const md=Math.max(1e-6, Math.hypot(mdx,mdy));
        m.x += (mdx/md) * speed * dt * 3.15;
        m.y += (mdy/md) * speed * dt * 3.15;
        if(md<0.08) m.stepCd=0;
      }

      // close-range dread
      if(dist < 3.2){
        run.anxiety = Math.max(run.anxiety, 9 + (3.2-dist)*4.5);
        if(Math.random()<0.03) triggerMessage();
      }

      // face flashes near
      if(dist < 2.0 && Math.random() < 0.006 + run.diffIndex*0.003){
        triggerFlash("face");
      }

      // damage zone
      hero.hitCD = Math.max(0, hero.hitCD-dt);
      if(dist < 0.64 && hero.hitCD<=0){
        hero.hitCD = 0.75;
        hero.panic++;
        hero.oxygen = Math.max(0, hero.oxygen - (12 + run.diffIndex*4));
        triggerMessage("DON'T LOOK");
        audio?.blip?.(1.0);
        triggerFlash("face");

        // shove away (collision resolver prevents corner glue)
        hero.x += (dx/dist)*0.40;
        hero.y += (dy/dist)*0.40;
        const r=resolveCircleGrid(hero.x, hero.y, PLAYER_RADIUS);
        hero.x=r.x; hero.y=r.y;

        if(hero.panic>=3){
          gameOver("CAUGHT IN THE BUFFER");
          return;
        }
      }

      // alerts decay
      m.alert = Math.max(0, (m.alert||0) - dt*0.35);
    }

    const fear = clamp(1 - closest/6, 0, 1);
    audio?.setFear?.(fear);

    // hallucinations also modulate audio
    const halluNorm = clamp(hero.hallucination/60, 0, 1);
    audio?.setHallu?.(halluNorm);
  }

  /* ============================================================
     LEVEL GEN
  ============================================================ */
  let collectedCount=0;

  function generateLevel(){
    generateBraidedMaze();

    stains=[];
    for(let i=0;i<STAINS;i++){
      stains.push(randomFloorFar(1,1,4));
    }

    offerings=[];
    while(offerings.length<TOTAL_OFFERINGS){
      const r=randomFloorFar(1,1,6);
      if(offerings.some(o=>o.x===r.x&&o.y===r.y)) continue;
      offerings.push({x:r.x,y:r.y,collected:false,order:0});
    }

    chests=[];
    while(chests.length<CHESTS_PER_LEVEL){
      const r=randomFloorFar(1,1,5);
      if(chests.some(c=>c.x===r.x&&c.y===r.y)) continue;
      if(offerings.some(o=>o.x===r.x&&o.y===r.y)) continue;
      chests.push({x:r.x,y:r.y,opened:false});
    }

    oxyTanks=[];
    while(oxyTanks.length<OXY_TANKS){
      const r=randomFloorFar(1,1,6);
      if(offerings.some(o=>o.x===r.x&&o.y===r.y)) continue;
      if(chests.some(c=>c.x===r.x&&c.y===r.y)) continue;
      oxyTanks.push({x:r.x,y:r.y,used:false});
    }

    exit=randomFloorFar(1,1,12);
    exitLocked=true;

    collectedCount=0;
    messages=[];
    run.anxiety=0;

    hero.x=1.5; hero.y=1.5;
    hero.vx=0; hero.vy=0;
    hero.oxygen = hero.oxygenMax;
    hero.panic=0;
    hero.hitCD=0;
    hero.actionCD=0;
    hero.animT=0;

    mission.active=false;
    mission.completed=false;
    prompt.active=false;
    pulse.active=false;
    flash.active=false;

    spawnMonsters();
    updateHUD();
  }

  /* ============================================================
     PICKUPS
  ============================================================ */
  function openChest(c){
    c.opened=true;
    triggerMessage("CHEST OPENED");
    audio?.blip?.(1.0);
    if(Math.random()<0.78) triggerFlash("face");

    if(!mission.active && exitLocked){
      setMission(generateRandomMission());
    } else if(Math.random()<0.6){
      showPrompt(pick(lorePrompts));
    }
  }

  function collectOffering(o){
    if(mission.active && mission.type==="FOLLOW_ORDER"){
      const needed=(mission.extra?.needed ?? 1);
      if(o.order !== needed){
        triggerMessage("WRONG SEQUENCE");
        run.anxiety=Math.max(run.anxiety,18);
        audio?.blip?.(1.0);
        triggerFlash("face");
        generateLevel();
        return;
      }
      mission.extra.needed = needed+1;
      if(mission.extra.needed > TOTAL_OFFERINGS){
        completeMission();
      }
    }

    o.collected=true;
    collectedCount++;
    triggerMessage("OFFERING ACCEPTED");
    pushMessage(`${hero.name.toUpperCase()}: MEMORY INDEXED`, "#fff");
    audio?.blip?.(0.9);

    if(Math.random()<0.55) triggerFlash("face");
    if(Math.random()<0.32) showPrompt(pick(lorePrompts));

    updateHUD();
  }

  function takeOxy(t){
    t.used=true;
    hero.oxygen = Math.min(hero.oxygenMax, hero.oxygen + OXY_TANK_GAIN);
    pushMessage("OXYGEN TANK", PAL.ui);
    audio?.blip?.(0.6);
  }

  /* ============================================================
     DIFFICULTY (random per run)
  ============================================================ */
  const DIFF_LABELS=["SICKLY","MEAN","FAMISHED","RABID"];

  function pickDifficulty(){
    run.diffIndex = (Math.random()*4)|0;
    run.diffLabel = DIFF_LABELS[run.diffIndex];

    run.monstersCount = 1 + ((Math.random()*2)|0) + (run.diffIndex>1?1:0); // 1..3
    run.aggression = 0.95 + run.diffIndex*0.12 + Math.random()*0.08;
    run.oxygenDrain = 0.92 + run.diffIndex*0.12 + Math.random()*0.10;

    // role tweaks
    hero.oxygenMax = BASE_OXYGEN;
    if(hero.role==="thief"){
      run.oxygenDrain *= 0.94;
    } else if(hero.role==="killer"){
      run.aggression *= 1.06;
    } else if(hero.role==="butcher"){
      hero.oxygenMax = BASE_OXYGEN + 10;
    }
    hero.oxygen = hero.oxygenMax;
  }

  /* ============================================================
     HUD
  ============================================================ */
  function updateHUD(){
    hName.textContent = `NAME: ${hero.name.toUpperCase()}`;
    hRole.textContent = `ROLE: ${hero.role.toUpperCase()}`;
    hDiff.textContent = `DIFF: ${run.diffLabel} · M${run.monstersCount}`;
    hLoot.textContent = `CHESTS ${chests.filter(c=>c.opened).length}/${CHESTS_PER_LEVEL}`;
    hOff.textContent  = `OFFERINGS ${collectedCount}/${TOTAL_OFFERINGS}`;

    hMission.textContent = mission.active ? mission.title : (exitLocked ? "LOCKED" : "UNSEALED");
    const mpct = mission.active ? clamp(mission.progress/mission.goal,0,1) : (exitLocked?0:1);
    hMis.style.width = `${(mpct*100)|0}%`;

    const opct = clamp(hero.oxygen/hero.oxygenMax,0,1);
    hOxy.style.width = `${(opct*100)|0}%`;

    hAtk.textContent = hero.actionCD>0 ? `ACTION: ${hero.actionCD.toFixed(1)}s` : "ACTION: READY";
  }

  /* ============================================================
     VISUAL EFFECTS: grain + hallucinations layer
  ============================================================ */
  function drawNoise(amount){
    if(amount<=0) return;
    ctx.save();
    ctx.globalAlpha = Math.min(0.24, amount/50);
    for(let i=0;i<140;i++){
      const x=Math.random()*W, y=Math.random()*H;
      const w=1+Math.random()*2, h=1+Math.random()*2;
      ctx.fillStyle = Math.random()<0.5 ? "#0b0b0b" : "#171717";
      ctx.fillRect(x,y,w,h);
    }
    ctx.restore();
  }

  function hallucinationOverlay(h){
    if(h<=0) return;
    const n = clamp(h/60, 0, 1);

    // subtle mirror slices
    if(Math.random() < 0.10*n){
      const y = (Math.random()*H)|0;
      const hgt = 6 + ((Math.random()*30)|0);
      const xOff = ((Math.random()*40)-20)|0;
      ctx.save();
      ctx.globalAlpha = 0.10 + 0.20*n;
      ctx.drawImage(canvas, 0, y, W, hgt, xOff, y, W, hgt);
      ctx.restore();
    }

    // fake exit flashes
    if(Math.random() < 0.018*n){
      ctx.save();
      ctx.globalAlpha = 0.25 + 0.25*n;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillRect((Math.random()*W)|0, (Math.random()*H)|0, 8, 10);
      ctx.restore();
    }

    // whisper name
    if(Math.random() < 0.02*n){
      pushMessage(hero.name.toUpperCase(), Math.random()<0.5?PAL.danger:"#fff");
    }

    // face flash frequency increases
    if(Math.random() < 0.008 + 0.03*n){
      triggerFlash("face");
    }
  }

  /* ============================================================
     UPDATE LOOP
  ============================================================ */
  let lastT=performance.now();

  function update(){
    const now=performance.now();
    const dt=Math.min(0.05,(now-lastT)/1000);
    lastT=now;

    // prompt timer
    if(prompt.active){
      prompt.timer -= dt;
      if(prompt.timer<=0){
        prompt.active=false;
        triggerMessage("NO RESPONSE");
        run.anxiety=Math.max(run.anxiety,14);
        run.aggression += 0.06;
      }
    }

    // oxygen drain (+ hallucination penalty)
    const sprinting=!!keys.ShiftLeft;
    hRun.textContent = `RUN: ${sprinting?"ON":"OFF"}`;

    const halluNorm = clamp(hero.hallucination/60, 0, 1);
    const halluDrain = 1 + halluNorm*0.45;
    const drain = run.oxygenDrain * (sprinting ? RUN_OXY_MULT : 1.0) * halluDrain;

    hero.oxygen = Math.max(0, hero.oxygen - drain*dt);
    if(hero.oxygen<=0){ gameOver("NO AIR LEFT"); return; }

    // movement (smooth accel)
    let ix=0,iy=0;
    if(keys.KeyW||keys.ArrowUp) iy-=1;
    if(keys.KeyS||keys.ArrowDown) iy+=1;
    if(keys.KeyA||keys.ArrowLeft) ix-=1;
    if(keys.KeyD||keys.ArrowRight) ix+=1;
    if(ix||iy){
      const l=Math.hypot(ix,iy); ix/=l; iy/=l;
    }

    const maxSpeed = sprinting ? MAX_RUN : MAX_WALK;
    hero.vx += ix*ACCEL*dt;
    hero.vy += iy*ACCEL*dt;

    const sp=Math.hypot(hero.vx,hero.vy);
    if(sp>maxSpeed){
      hero.vx *= maxSpeed/sp;
      hero.vy *= maxSpeed/sp;
    }

    hero.vx *= Math.pow(FRICTION, dt*60);
    hero.vy *= Math.pow(FRICTION, dt*60);

    // integrate + resolve
    let nx=hero.x + hero.vx*dt;
    let ny=hero.y + hero.vy*dt;
    const r=resolveCircleGrid(nx, ny, PLAYER_RADIUS);
    hero.x=r.x; hero.y=r.y;

    const moving = Math.abs(hero.vx)+Math.abs(hero.vy) > 0.01;

    // anxiety
    if(sprinting) run.anxiety = Math.min(run.anxiety + 0.35, 18);
    else run.anxiety = Math.max(run.anxiety - 0.12, 0);

    // stains influence
    for(const s of stains){
      const d=Math.hypot((s.x+0.5)-hero.x,(s.y+0.5)-hero.y);
      if(d<1.05){
        run.anxiety = Math.max(run.anxiety, 7);
        if(Math.random()<0.014) triggerMessage("COLOR BLEED");
        if(Math.random()<0.005) showPrompt(pick(lorePrompts));
      }
    }

    // mission
    updateMission(dt, moving, sprinting);

    // monsters
    updateMonsters(dt);

    // pulse ring
    if(pulse.active){
      pulse.t += dt*12;
      pulse.ring = pulse.t;
      if(pulse.t>25) pulse.active=false;
    }

    // flash
    if(flash.active){
      flash.t += dt;
      if(flash.t < flash.dur*0.2) flash.alpha = flash.t/(flash.dur*0.2);
      else flash.alpha = 1 - (flash.t - flash.dur*0.2)/(flash.dur*0.8);
      if(flash.t >= flash.dur){ flash.active=false; flash.alpha=0; }
    }

    // action cd
    hero.actionCD = Math.max(0, hero.actionCD-dt);

    // hallucination decay
    hero.hallucination = Math.max(0, hero.hallucination - dt*HALLU_DECAY_PER_SEC);

    // pickups
    for(const c of chests){
      if(c.opened) continue;
      if(Math.hypot((c.x+0.5)-hero.x,(c.y+0.5)-hero.y) < 0.72) openChest(c);
    }
    for(const o of offerings){
      if(o.collected) continue;
      if(Math.hypot((o.x+0.5)-hero.x,(o.y+0.5)-hero.y) < 0.72) collectOffering(o);
    }
    for(const t of oxyTanks){
      if(t.used) continue;
      if(Math.hypot((t.x+0.5)-hero.x,(t.y+0.5)-hero.y) < 0.72) takeOxy(t);
    }

    // exit
    if(exit && !exitLocked){
      if(Math.hypot((exit.x+0.5)-hero.x,(exit.y+0.5)-hero.y) < 0.62){
        win();
        return;
      }
    }

    // message life
    for(let i=messages.length-1;i>=0;i--){
      messages[i].life--;
      if(messages[i].life<=0) messages.splice(i,1);
    }

    // animate hero
    hero.animT += dt;

    updateHUD();
  }

  /* ============================================================
     RENDER
  ============================================================ */
  function render(){
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);

    const shake=Math.min(6, run.anxiety*0.45);
    const sx=(Math.random()-0.5)*shake*(hero.hallucination>0?1.25:1);
    const sy=(Math.random()-0.5)*shake*(hero.hallucination>0?1.25:1);

    const camX = -hero.x*TILE + W/2 + sx;
    const camY = -hero.y*TILE + H/2 + sy;

    const viewRadius = clamp(BASE_FOV - (run.anxiety/5) + (pulse.active?2.4:0), MIN_FOV, MAX_FOV);

    // map
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const dist=Math.hypot((x+0.5)-hero.x,(y+0.5)-hero.y);

        let vis=0;
        if(dist<viewRadius){
          vis=1-(dist/viewRadius);
          vis=Math.pow(vis,0.62);
        }

        if(pulse.active){
          if(Math.abs(dist - pulse.ring)<1.5){
            vis += 0.48*(1-(Math.abs(dist-pulse.ring)/1.5));
          }
        }

        if(vis<=0.01) continue;
        vis=clamp(vis,0,1);

        const px=camX + x*TILE;
        const py=camY + y*TILE;

        ctx.save();
        ctx.globalAlpha=vis;

        if(map[y][x]===1){
          ctx.fillStyle=PAL.wall;
          ctx.fillRect(px,py,TILE,TILE);
          ctx.strokeStyle="rgba(0,0,0,0.35)";
          ctx.strokeRect(px,py,TILE,TILE);
        } else {
          ctx.fillStyle=PAL.floor;
          ctx.fillRect(px,py,TILE,TILE);

          const st = stains.find(s=>s.x===x && s.y===y);
          if(st){
            ctx.fillStyle = Math.random()<0.5 ? "rgba(160,0,50,0.40)" : "rgba(80,0,120,0.30)";
            ctx.fillRect(px,py,TILE,TILE);
          }
        }
        ctx.restore();
      }
    }

    // objects
    function drawObj(tx,ty,color,shape){
      const dist=Math.hypot((tx+0.5)-hero.x,(ty+0.5)-hero.y);
      if(dist>viewRadius && !(pulse.active && Math.abs(dist-pulse.ring)<1.5)) return;
      const x=camX + tx*TILE;
      const y=camY + ty*TILE;

      ctx.fillStyle=color;
      if(shape==="box") ctx.fillRect(x+4,y+4,8,8);
      else if(shape==="circle"){
        ctx.beginPath(); ctx.arc(x+8,y+8,4,0,Math.PI*2); ctx.fill();
      } else if(shape==="diamond"){
        ctx.beginPath();
        ctx.moveTo(x+8,y+2); ctx.lineTo(x+14,y+8);
        ctx.lineTo(x+8,y+14); ctx.lineTo(x+2,y+8);
        ctx.closePath(); ctx.fill();
      }
    }

    chests.forEach(c=>{ if(!c.opened) drawObj(c.x,c.y,"#3a88aa","box"); });

    offerings.forEach(o=>{
      if(o.collected) return;
      const col = (mission.active && mission.type==="FOLLOW_ORDER")
        ? (o.order===1 ? "#ff3355" : o.order===2 ? "#44ff88" : "#4488ff")
        : "#ddcc44";
      drawObj(o.x,o.y,col,"circle");
    });

    oxyTanks.forEach(t=>{ if(!t.used) drawObj(t.x,t.y,"#55ddff","box"); });

    if(exit){
      drawObj(exit.x, exit.y, exitLocked ? "#550000" : "#ffffff", "diamond");
      if(!exitLocked){
        const x=camX + exit.x*TILE;
        const y=camY + exit.y*TILE;
        ctx.fillStyle="rgba(255,60,90,0.7)";
        ctx.fillRect(x+7,y+3,2,TILE-6);
      }
    }

    // monsters
    for(const m of monsters){
      if(m.deadTimer>0) continue;
      const dist=Math.hypot(m.x-hero.x,m.y-hero.y);
      if(dist<viewRadius+1.6){
        const x=camX + m.x*TILE - 10;
        const y=camY + m.y*TILE - 10;
        const jx=(Math.random()-0.5)*2;
        const jy=(Math.random()-0.5)*2;
        ctx.globalAlpha=0.85;
        ctx.drawImage(monsterSprite, x+jx, y+jy);

        // HP hint (subtle) when close enough (not too gamey)
        if(dist<2.2){
          const pct=clamp(m.hp/m.hpMax,0,1);
          ctx.globalAlpha=0.6;
          ctx.fillStyle="rgba(255,255,255,0.15)";
          ctx.fillRect(x, y-3, 20, 2);
          ctx.fillStyle="rgba(255,51,85,0.85)";
          ctx.fillRect(x, y-3, 20*pct, 2);
        }
        ctx.globalAlpha=1;
      }
    }

    // hero sprite (creepy animated, role tint)
    const hx=W/2, hy=H/2;
    const breath=1 + Math.sin(hero.animT*3.2)*0.10;
    const jitter=(Math.random()-0.5)*(0.6 + run.anxiety*0.08 + (hero.hallucination>0?0.4:0));

    let tint = hero.role==="thief" ? "rgba(180,220,210,0.95)"
             : hero.role==="killer" ? "rgba(220,190,200,0.95)"
             : "rgba(220,210,180,0.95)";

    ctx.save();
    ctx.translate(hx+jitter, hy+jitter);

    // aura corruption
    ctx.globalAlpha=0.18;
    ctx.fillStyle="rgba(255,60,90,0.35)";
    ctx.fillRect(-6,-6,12,12);

    // delayed shadow smear
    ctx.globalAlpha=0.12;
    ctx.fillStyle="rgba(0,0,0,0.9)";
    ctx.fillRect(-2 + Math.sin(hero.animT*2.1)*2, -2, 4, 6);

    ctx.globalAlpha=1;
    ctx.fillStyle=tint;
    ctx.fillRect(-2, -2, 4, 4*breath);

    // head
    ctx.fillStyle="rgba(0,0,0,0.85)";
    ctx.fillRect(-1, -4, 2, 2);

    // role marks
    ctx.fillStyle= hero.role==="thief" ? "rgba(80,255,200,0.65)"
               : hero.role==="killer" ? "rgba(255,80,140,0.65)"
               : "rgba(255,210,80,0.65)";
    ctx.fillRect(-3, 1, 1, 1);
    ctx.fillRect( 2, 1, 1, 1);

    ctx.restore();

    // hallucination overlay (post-render)
    hallucinationOverlay(hero.hallucination);

    // flash overlay
    if(flash.active && flash.img){
      ctx.globalAlpha = flash.alpha*0.85;
      ctx.drawImage(flash.img, 0,0, W,H);
      ctx.globalAlpha = 1;
    }

    // grain
    drawNoise(run.anxiety + (hero.hallucination>0?8:0));

    // messages
    ctx.font="14px VT323";
    ctx.textAlign="left";
    for(const m of messages){
      ctx.fillStyle=m.color;
      ctx.globalAlpha=Math.min(1, m.life/20);
      ctx.fillText(m.text, m.x, m.y);
    }
    ctx.globalAlpha=1;

    // prompt / mission UI
    if(prompt.active){
      ctx.fillStyle="rgba(0,0,0,0.88)";
      ctx.fillRect(18, 150, 284, 76);
      ctx.strokeStyle="rgba(204,255,204,0.65)";
      ctx.strokeRect(18, 150, 284, 76);

      ctx.fillStyle="#fff";
      ctx.textAlign="center";
      ctx.fillText(prompt.text, 160, 170);
      ctx.fillStyle="#bbb";
      ctx.fillText(prompt.a, 160, 192);
      ctx.fillText(prompt.b, 160, 208);

      ctx.fillStyle=PAL.danger;
      ctx.fillRect(20, 222, 280*clamp(prompt.timer/6.6,0,1), 2);
      ctx.textAlign="left";
    } else if(mission.active){
      ctx.fillStyle="rgba(0,0,0,0.55)";
      ctx.fillRect(6, 200, 185, 34);
      ctx.strokeStyle="rgba(204,255,204,0.25)";
      ctx.strokeRect(6, 200, 185, 34);

      ctx.fillStyle=PAL.ui;
      ctx.fillText(mission.title, 10, 212);

      const pct=clamp(mission.progress/mission.goal,0,1);
      ctx.fillStyle="rgba(255,255,255,0.16)";
      ctx.fillRect(10, 217, 110, 4);
      ctx.fillStyle=PAL.ui;
      ctx.fillRect(10, 217, 110*pct, 4);

      ctx.fillStyle="#aaa";
      const line = mission.desc.split("\n")[1] || "";
      ctx.fillText(line, 10, 232);
    }
  }

  /* ============================================================
     GAME LOOP
  ============================================================ */
  function tick(){
    if(started){
      update();
      render();
    } else {
      ctx.fillStyle="#000";
      ctx.fillRect(0,0,W,H);
      drawNoise(6);
    }
    requestAnimationFrame(tick);
  }

  /* ============================================================
     START / END
  ============================================================ */
  async function startGame(){
    if(started) return;

    const nm=(nameInput.value||"").trim();
    hero.name = nm ? nm.slice(0,18) : "UNKNOWN";
    hero.role = roleInput.value || "thief";

    pickDifficulty();
    await ensureAudioRunning();

    overlay.style.display="none";
    started=true;

    pushMessage(generateLore(), "#fff");
    triggerMessage("BOOTING LEVEL");

    generateLevel();
  }

  function gameOver(reason){
    started=false;
    alert(`${reason}\n\nRUN END.\n${hero.name.toUpperCase()} WAS ARCHIVED.`);
    location.reload();
  }

  function win(){
    started=false;
    alert(`EXIT UNSEALED.\n${hero.name.toUpperCase()} WAS UPLOADED.\n\nTHE MAZE SAVES COPIES.`);
    location.reload();
  }

  /* ============================================================
     BOOT
  ============================================================ */
  updateHUD();
  tick();

})();
</script>
</body>
</html>

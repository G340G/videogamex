<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>ENTROPY.DAT</title>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#050505;
    --fg:#cfd6d3;
    --green:#ccffcc;
    --red:#ff3355;
    --dim:rgba(255,255,255,.65);
  }
  html,body{
    margin:0; height:100%;
    background:var(--bg);
    color:var(--fg);
    font-family:'VT323',monospace;
    overflow:hidden;
    user-select:none;
  }
  .wrap{
    height:100%;
    display:grid;
    place-items:center;
  }
  .crt{
    width:640px; height:480px;
    position:relative;
    border:1px solid #333;
    box-shadow:0 0 24px rgba(0,0,0,.85);
    background:#000;
  }
  canvas{
    width:100%; height:100%;
    image-rendering:pixelated;
    display:block;
    background:#000;
  }
  .scanlines{
    position:absolute; inset:0;
    background:linear-gradient(to bottom,
      rgba(255,255,255,0),
      rgba(255,255,255,0) 50%,
      rgba(0,0,0,.22) 50%,
      rgba(0,0,0,.22)
    );
    background-size:100% 4px;
    pointer-events:none;
    z-index:10;
  }
  .crt::after{
    content:"";
    position:absolute; inset:0;
    background:rgba(18,16,16,.10);
    opacity:0;
    pointer-events:none;
    z-index:10;
    animation:flicker .14s infinite;
  }
  @keyframes flicker{0%{opacity:.02}50%{opacity:.06}100%{opacity:.02}}

  /* HUD: keep it small */
  .hud{
    position:absolute;
    top:8px; left:8px;
    z-index:20;
    font-size:18px;
    color:var(--green);
    text-shadow:0 0 6px rgba(204,255,204,.35);
    pointer-events:none;
    max-width: 240px;
    line-height:1.05;
  }
  .hud .row{ display:flex; gap:10px; flex-wrap:wrap; }
  .hud .pill{
    background:rgba(0,0,0,.55);
    border:1px solid rgba(204,255,204,.22);
    padding:4px 6px;
  }
  .hud .status{ color:var(--dim); border-color:rgba(255,255,255,.12); }
  .hud .warn{ color:var(--red); border-color:rgba(255,51,85,.25); }

  /* Mission box bottom-left but compact */
  .missionBox{
    position:absolute;
    left:8px;
    bottom:8px;
    z-index:20;
    width: 250px;
    padding:8px;
    background:rgba(0,0,0,.65);
    border:1px solid rgba(255,255,255,.12);
    color:rgba(255,255,255,.85);
    pointer-events:none;
    display:none;
  }
  .missionBox .title{
    color:var(--green);
    font-size:18px;
    margin-bottom:2px;
  }
  .missionBox .desc{
    opacity:.85;
    font-size:16px;
    white-space:pre-line;
  }
  .missionBox .bar{
    height:4px;
    background:rgba(255,255,255,.12);
    margin-top:6px;
    position:relative;
  }
  .missionBox .bar > i{
    position:absolute; top:0; left:0; bottom:0;
    background:rgba(204,255,204,.85);
    width:0%;
    display:block;
  }

  /* Prompt box centered */
  .promptBox{
    position:absolute;
    inset:auto 12px 110px 12px;
    margin:auto;
    width: 560px;
    z-index:25;
    padding:10px 12px;
    background:rgba(0,0,0,.82);
    border:1px solid rgba(204,255,204,.22);
    color:rgba(255,255,255,.92);
    text-align:center;
    display:none;
    pointer-events:none;
  }
  .promptBox .q{ font-size:20px; color:rgba(255,255,255,.95); }
  .promptBox .a{ margin-top:6px; font-size:18px; opacity:.88; }
  .promptBox .timer{
    height:3px; margin-top:8px;
    background:rgba(255,255,255,.10);
    position:relative;
  }
  .promptBox .timer > i{
    position:absolute; left:0; top:0; bottom:0;
    width:100%;
    background:rgba(255,51,85,.75);
  }

  /* Menu */
  .menu{
    position:absolute; inset:0;
    z-index:30;
    display:grid;
    place-items:center;
    background:radial-gradient(circle at center, rgba(0,0,0,.35), rgba(0,0,0,.92));
  }
  .panel{
    width:min(520px, 92%);
    padding:16px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.65);
    text-align:center;
    box-shadow:0 0 18px rgba(0,0,0,.7);
  }
  .title{
    font-size:56px;
    letter-spacing:2px;
    color:var(--green);
    text-shadow:0 0 10px rgba(204,255,204,.25);
    margin-bottom:6px;
  }
  .sub{ font-size:22px; opacity:.8; margin-bottom:10px; }
  .grid{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:10px;
    margin:12px 0;
    text-align:left;
  }
  label{ font-size:18px; opacity:.85; display:block; margin-bottom:4px;}
  input,select,button{
    width:100%;
    font-family:'VT323', monospace;
    font-size:22px;
    padding:8px 10px;
    background:#000;
    color:var(--fg);
    border:1px solid rgba(255,255,255,.22);
    box-sizing:border-box;
  }
  button{
    cursor:pointer;
    color:#000;
    background:var(--green);
    border-color:rgba(204,255,204,.35);
  }
  button:active{ transform:translateY(1px); }
  .hint{
    margin-top:10px;
    font-size:18px;
    opacity:.7;
    line-height:1.1;
  }
  .tiny{ opacity:.55; font-size:16px; margin-top:8px; }

  /* Simple bottom hint */
  .controlsHint{
    margin-top:10px;
    text-align:center;
    opacity:.55;
    font-size:18px;
  }

</style>
</head>
<body>
<div class="wrap">
  <div class="crt" id="crt">
    <div class="scanlines"></div>

    <div class="hud" id="hud">
      <div class="row">
        <div class="pill" id="hudLeft">NAME</div>
        <div class="pill status" id="hudStatus">STATUS: IDLE</div>
      </div>
      <div class="row" style="margin-top:6px;">
        <div class="pill" id="hudOxy">O2: 100%</div>
        <div class="pill" id="hudDiff">DIFF: ?</div>
      </div>
      <div class="row" style="margin-top:6px;">
        <div class="pill" id="hudItems">CHESTS: 0/0</div>
      </div>
    </div>

    <div class="missionBox" id="missionBox">
      <div class="title" id="missionTitle">MISSION</div>
      <div class="desc" id="missionDesc">...</div>
      <div class="bar"><i id="missionBar"></i></div>
    </div>

    <div class="promptBox" id="promptBox">
      <div class="q" id="promptQ">...</div>
      <div class="a" id="promptA">...</div>
      <div class="timer"><i id="promptBar"></i></div>
    </div>

    <canvas id="game" width="320" height="240"></canvas>

    <div class="menu" id="menu">
      <div class="panel">
        <div class="title">ENTROPY.DAT</div>
        <div class="sub" id="loreIntro">A corrupted tape is waiting.</div>

        <div class="grid">
          <div>
            <label for="name">PROTAGONIST NAME</label>
            <input id="name" autocomplete="off" placeholder="e.g. MARTA" />
          </div>
          <div>
            <label for="role">ROLE</label>
            <select id="role">
              <option value="thief">THIEF</option>
              <option value="killer">KILLER</option>
              <option value="butcher">BUTCHER</option>
            </select>
          </div>
        </div>

        <button id="startBtn">START</button>

        <div class="hint">
          WASD / Arrows · Shift = Run (louder) · E = Signal Pulse<br>
          Chests unlock missions. Complete mission to unseal the exit.
        </div>
        <div class="tiny">
          Tip: If audio doesn’t start, click START again (browser gesture lock).
        </div>
      </div>
    </div>
  </div>

  <div class="controlsHint">
    Low-res fog horror · abstract missions · choices matter · always different.
  </div>
</div>

<script>
(() => {
  // ========= CONFIG =========
  const TILE = 16, COLS = 20, ROWS = 15;
  const CAN_W = 320, CAN_H = 240;

  // Physics / movement
  const PLAYER_R = 0.28;             // circle radius (tiles)
  const ACCEL = 18.0;                // tiles/s^2
  const FRICTION = 16.0;             // tiles/s^2
  const MAX_SPEED = 2.25;            // tiles/s walk
  const RUN_MULT = 1.55;

  // Visibility
  const BASE_FOV = 6.2;
  const MIN_FOV = 4.4;
  const MAX_FOV = 7.2;

  // Oxygen baseline (>= 60s demanded)
  const BASE_OXY_SECONDS = 90;       // walking ~90s baseline
  const RUN_OXY_MULT = 1.75;         // running drains faster
  const LOW_OXY_WARN = 15;           // seconds

  // Level content
  const CHESTS_PER_LEVEL_BASE = 3;
  const TANKS_PER_LEVEL_BASE = 3;
  const OFFERINGS_PER_LEVEL = 3;

  // Monster tuning (winnable + abrasive)
  const MONSTER_BASE_SPEED = 1.10;   // tiles/s
  const MONSTER_HEAR_WALK = 4.7;
  const MONSTER_HEAR_RUN  = 7.9;
  const MONSTER_HIT_DIST  = 0.62;
  const MONSTER_HIT_COOLDOWN = 1.2;  // seconds between hits
  const STRIKES_TO_DIE = 2;

  // Visual noise
  const GRAIN_PARTICLES = 160;

  // ========= DOM =========
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });

  const menu = document.getElementById('menu');
  const startBtn = document.getElementById('startBtn');
  const nameInput = document.getElementById('name');
  const roleSelect = document.getElementById('role');
  const loreIntroEl = document.getElementById('loreIntro');

  const hudLeft = document.getElementById('hudLeft');
  const hudStatus = document.getElementById('hudStatus');
  const hudOxy = document.getElementById('hudOxy');
  const hudDiff = document.getElementById('hudDiff');
  const hudItems = document.getElementById('hudItems');

  const missionBox = document.getElementById('missionBox');
  const missionTitleEl = document.getElementById('missionTitle');
  const missionDescEl = document.getElementById('missionDesc');
  const missionBarEl = document.getElementById('missionBar');

  const promptBox = document.getElementById('promptBox');
  const promptQEl = document.getElementById('promptQ');
  const promptAEl = document.getElementById('promptA');
  const promptBarEl = document.getElementById('promptBar');

  // ========= INPUT =========
  const keys = Object.create(null);
  const justPressed = Object.create(null);

  function onKeyDown(e){
    // Avoid page scrolling on arrows/space
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();

    if (!keys[e.code]) justPressed[e.code] = true;
    keys[e.code] = true;

    // Respond to prompt with 1/2 even if moving
    if (state.mode === "PLAY" && prompt.active){
      if (e.code === "Digit1") choosePrompt(1);
      if (e.code === "Digit2") choosePrompt(2);
    }

    // Start from keyboard, but ONLY if not typing in inputs
    if (state.mode === "MENU" && (e.code === "Enter")){
      const ae = document.activeElement;
      const typing = (ae === nameInput || ae === roleSelect);
      if (!typing) startGameFromMenu();
    }

    // E pulse
    if (state.mode === "PLAY" && e.code === "KeyE") triggerPulse();
  }
  function onKeyUp(e){ keys[e.code] = false; }
  window.addEventListener('keydown', onKeyDown, { passive:false });
  window.addEventListener('keyup', onKeyUp, { passive:true });

  // ========= RNG helpers =========
  const clamp = (v,a,b)=> v<a?a : v>b?b : v;
  const rand = (a,b)=> a + Math.random()*(b-a);
  const randi = (a,b)=> (a + Math.floor(Math.random()*(b-a+1)));
  const pick = (arr)=> arr[(Math.random()*arr.length)|0];

  // ========= STATE =========
  const state = {
    mode: "MENU", // MENU | PLAY
    seed: (Math.random()*1e9)|0,
    time: 0,
    anxiety: 0,
    strikes: 0,
    camShake: 0,
  };

  const hero = {
    name: "UNKNOWN",
    role: "thief",
    x: 1.5, y: 1.5,
    vx: 0, vy: 0,
    oxygen: BASE_OXY_SECONDS,
    maxOxygen: BASE_OXY_SECONDS,
    hitCooldown: 0,
    sanity: 100,
  };

  let map = [];
  let stains = [];
  let chests = [];
  let tanks = [];
  let offerings = [];
  let exit = { x: 0, y: 0, unlocked:false };

  let messages = []; // floating glitch text
  let flash = { active:false, t:0, dur:0.8, img:null, alpha:0, kind:"" };
  let facePopup = { active:false, t:0, dur:0.55, img:null, intensity:0 };

  let pulse = { active:false, t:0, dirX:0, dirY:0, ring:0 };

  // Mission
  const mission = {
    active:false,
    title:"",
    desc:"",
    type:"",
    progress:0,
    goal:1,
    extra:null,
    completed:false,
  };

  // Prompt
  const prompt = {
    active:false,
    q:"",
    a:"",
    timer:0,
    onChoose:null,
    maxTime: 6.5
  };

  // Difficulty per run
  const diff = {
    name:"NORMAL",
    oxygenDrain: 1.0,
    monsters: 1,
    monsterSpeed: 1.0,
    fog: 1.0,
    missionHard: 1.0,
    aggression: 1.0,
  };

  // Monsters (multiple)
  const monsters = [];

  // ========= TEXT BANKS =========
  const cryptic = [
    "NULL REFERENCE","FRAME DROP","DE-SYNC","SIGNAL BLEED","YOU ARE DATA",
    "EYES IN THE FOG","DOOR IS NOT A DOOR","THE MAZE REMEMBERS","PAINTED AIR",
    "NEGATIVE SPACE","UNSAFE POINTER","STATIC...","1997","DON'T LOOK",
    "THE TAPE IS WATCHING","MISSING INDEX","SPOOL CORRUPTION"
  ];

  function pushMessage(text, color=null){
    messages.push({
      text,
      x: Math.random()*CAN_W,
      y: Math.random()*CAN_H,
      life: 70,
      color: color || (Math.random()<0.55 ? "#ff3355" : "#ffffff")
    });
  }

  function randomLoreIntro(name, role){
    const victims = ["a kidnapped lady","a missing child","a vanished caretaker","a girl in a hospital gown","a witness in a motel"];
    const places  = ["a fog-choked corridor","a service tunnel","a flooded archive","a dead shopping center","a basement with humming walls"];
    const objects = ["a tape labeled ENTROPY.DAT","a ring of keys that aren’t yours","a bag of teeth","a bloodless apron","a broken pager"];
    const hooks   = [
      "The air tastes like old coins.",
      "You can hear a siren that isn’t there.",
      "Your footsteps arrive late.",
      "The walls remember your name incorrectly.",
      "Something keeps counting your breaths."
    ];

    const roleLine =
      role==="thief"   ? "You steal locks. The locks steal you back." :
      role==="killer"  ? "You know how to end people. The maze knows how to end you." :
                         "You cut meat. Here, the meat looks back.";

    const victim = pick(victims);
    const place  = pick(places);
    const obj    = pick(objects);
    const hook   = pick(hooks);

    const pro = name && name.trim() ? name.trim().toUpperCase() : "UNKNOWN";
    return `${pro}: You came for ${victim}.\nYou woke up in ${place} holding ${obj}.\n${roleLine}\n${hook}\n\nOpen chests. Accept missions. Unseal the exit.`;
  }

  // ========= ASSET LOADER (your images) =========
  function loadImage(src){
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = src;
    });
  }

  const assets = {
    monster:null,
    face1:null,
    face2:null,
    flashes:[],
  };

  async function loadAssets(){
    // These will resolve null if not present — game still works.
    assets.monster = await loadImage("assets/monster.png");
    assets.face1 = await loadImage("assets/face1.png");
    assets.face2 = await loadImage("assets/face2.png");

    const f1 = await loadImage("assets/flash1.png");
    const f2 = await loadImage("assets/flash2.png");
    const f3 = await loadImage("assets/flash3.png");
    assets.flashes = [f1,f2,f3].filter(Boolean);
  }

  // ========= AUDIO (organic + abrasive) =========
  let audio = null;

  function initAudio(){
    if (audio) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    const ac = new AC();

    const master = ac.createGain();
    master.gain.value = 0.70;

    const limiter = ac.createDynamicsCompressor();
    limiter.threshold.value = -18;
    limiter.knee.value = 24;
    limiter.ratio.value = 8;
    limiter.attack.value = 0.004;
    limiter.release.value = 0.18;

    const pan = ac.createStereoPanner();
    pan.pan.value = 0;

    master.connect(limiter);
    limiter.connect(pan);
    pan.connect(ac.destination);

    // noise buffer (pink-ish)
    const noiseBuf = ac.createBuffer(1, ac.sampleRate*2, ac.sampleRate);
    {
      const d = noiseBuf.getChannelData(0);
      let last = 0;
      for (let i=0;i<d.length;i++){
        last = 0.985*last + 0.015*(Math.random()*2-1);
        d[i] = last;
      }
    }

    // Wind bed
    const wind = ac.createBufferSource();
    wind.buffer = noiseBuf; wind.loop = true;
    const windLP = ac.createBiquadFilter();
    windLP.type = "lowpass";
    windLP.frequency.value = 200;
    const windGain = ac.createGain();
    windGain.gain.value = 0.05;
    wind.connect(windLP); windLP.connect(windGain); windGain.connect(master);
    wind.start();

    // Radio static
    const stat = ac.createBufferSource();
    stat.buffer = noiseBuf; stat.loop = true;
    const statBP = ac.createBiquadFilter();
    statBP.type = "bandpass";
    statBP.frequency.value = 1100;
    statBP.Q.value = 0.9;
    const statGain = ac.createGain();
    statGain.gain.value = 0.018;
    stat.connect(statBP); statBP.connect(statGain); statGain.connect(master);
    stat.start();

    // Organic drone (two detuned sines + slow FM)
    const d1 = ac.createOscillator(); d1.type = "sine"; d1.frequency.value = 47;
    const d2 = ac.createOscillator(); d2.type = "sine"; d2.frequency.value = 47.6;
    const fm = ac.createOscillator(); fm.type = "sine"; fm.frequency.value = 0.09;
    const fmG = ac.createGain(); fmG.gain.value = 9.5;
    fm.connect(fmG); fmG.connect(d1.frequency); fmG.connect(d2.frequency);

    const droneLP = ac.createBiquadFilter();
    droneLP.type = "lowpass";
    droneLP.frequency.value = 420;

    const droneGain = ac.createGain();
    droneGain.gain.value = 0.026;

    d1.connect(droneLP); d2.connect(droneLP);
    droneLP.connect(droneGain); droneGain.connect(master);

    d1.start(); d2.start(); fm.start();

    // Heart / breathing (amplitude pulses)
    const breathOsc = ac.createOscillator();
    breathOsc.type = "triangle";
    breathOsc.frequency.value = 0.22;
    const breathGain = ac.createGain();
    breathGain.gain.value = 0.0; // modulates static/wind/drone subtle
    breathOsc.connect(breathGain);
    breathGain.connect(windGain.gain);
    breathGain.connect(droneGain.gain);
    breathOsc.start();

    // Abrasive ticks / glitches
    function blip(intensity=0.4){
      const t = ac.currentTime;
      const o = ac.createOscillator();
      o.type = Math.random()<0.5 ? "square" : "triangle";
      o.frequency.value = 140 + Math.random()*2200;

      const bp = ac.createBiquadFilter();
      bp.type="bandpass";
      bp.frequency.value = 500 + Math.random()*3200;
      bp.Q.value = 10;

      const g = ac.createGain();
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.08*intensity, t+0.002);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.09);

      o.connect(bp); bp.connect(g); g.connect(master);
      o.start(t); o.stop(t+0.1);
    }

    // Thump (for tanks / chest)
    function thump(intensity=0.25){
      const t = ac.currentTime;
      const o = ac.createOscillator();
      o.type="sine";
      o.frequency.setValueAtTime(60 + Math.random()*20, t);
      o.frequency.exponentialRampToValueAtTime(26, t+0.18);

      const g = ac.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.10*intensity, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.22);

      o.connect(g); g.connect(master);
      o.start(t); o.stop(t+0.25);
    }

    // Mutations (non-repeating)
    function mutate(){
      const t = ac.currentTime;
      statBP.frequency.setTargetAtTime(650 + Math.random()*3200, t, 1.6);
      statGain.gain.setTargetAtTime(0.010 + Math.random()*0.045, t, 1.0);
      windLP.frequency.setTargetAtTime(120 + Math.random()*320, t, 2.4);

      const base = 34 + Math.random()*65;
      d1.frequency.setTargetAtTime(base, t, 2.2);
      d2.frequency.setTargetAtTime(base + (Math.random()*1.4), t, 2.2);
      droneLP.frequency.setTargetAtTime(220 + Math.random()*1100, t, 2.1);

      if (Math.random()<0.18){
        d1.detune.setTargetAtTime((Math.random()<0.5?-1:1)*(90+Math.random()*220), t, 0.7);
        d2.detune.setTargetAtTime((Math.random()<0.5?-1:1)*(90+Math.random()*220), t, 0.7);
        setTimeout(()=>{
          d1.detune.setTargetAtTime(0, ac.currentTime, 1.0);
          d2.detune.setTargetAtTime(0, ac.currentTime, 1.0);
        }, 900 + Math.random()*1600);
      }

      setTimeout(mutate, 900 + Math.random()*1700);
    }

    function eventTick(){
      const fear = audio?.fear ?? 0;
      const oxy = audio?.oxy ?? 1;
      const chaos = fear*0.85 + (1-oxy)*0.9;
      if (Math.random() < 0.12 + chaos*0.35) blip(0.25 + Math.random()*(0.6+chaos));
      setTimeout(eventTick, 240 + Math.random()*(940 - chaos*520));
    }

    audio = {
      ac,
      fear: 0,
      oxy: 1,
      blip,
      thump,
      setFear(f){
        audio.fear = clamp(f,0,1);
        const t = ac.currentTime;
        // More fear = more static + sharper bandpass + louder drone
        statGain.gain.setTargetAtTime(0.012 + audio.fear*0.12, t, 0.08);
        statBP.Q.setTargetAtTime(0.9 + audio.fear*12, t, 0.12);
        droneGain.gain.setTargetAtTime(0.020 + audio.fear*0.10, t, 0.2);
        windGain.gain.setTargetAtTime(0.04 + audio.fear*0.10, t, 0.15);
        if (audio.fear>0.72 && Math.random()<0.07) blip(0.85*audio.fear);
      },
      setOxy(x){
        audio.oxy = clamp(x,0,1);
        const t = ac.currentTime;
        // Lower oxygen -> breathing modulation increases + lowpass moves
        const strain = (1-audio.oxy);
        breathOsc.frequency.setTargetAtTime(0.18 + strain*0.55, t, 0.22);
        breathGain.gain.setTargetAtTime(0.008 + strain*0.045, t, 0.18);
        windLP.frequency.setTargetAtTime(140 + (1-strain)*220, t, 1.0);
      },
      setObjectivePan(p){
        pan.pan.setTargetAtTime(clamp(p,-1,1), ac.currentTime, 0.12);
      }
    };

    setTimeout(mutate, 450);
    setTimeout(eventTick, 800);
  }

  async function ensureAudio(){
    initAudio();
    if (audio?.ac?.state === "suspended"){
      try { await audio.ac.resume(); } catch {}
    }
  }

  // ========= DIFFICULTY PER RUN =========
  function rollDifficulty(){
    const r = Math.random();
    if (r < 0.55){
      diff.name="NORMAL";
      diff.oxygenDrain = 1.00;
      diff.monsters = 1;
      diff.monsterSpeed = 1.00;
      diff.fog = 1.00;
      diff.missionHard = 1.00;
      diff.aggression = 1.00;
    } else if (r < 0.85){
      diff.name="HARD";
      diff.oxygenDrain = 1.20;
      diff.monsters = 2;
      diff.monsterSpeed = 1.10;
      diff.fog = 1.08;
      diff.missionHard = 1.25;
      diff.aggression = 1.12;
    } else {
      diff.name="HELL";
      diff.oxygenDrain = 1.40;
      diff.monsters = 3;
      diff.monsterSpeed = 1.22;
      diff.fog = 1.15;
      diff.missionHard = 1.45;
      diff.aggression = 1.22;
    }
  }

  // ========= MAP GEN =========
  function inBounds(x,y){ return x>=0 && y>=0 && x<COLS && y<ROWS; }
  function isWall(tx,ty){
    if (!inBounds(tx,ty)) return true;
    return map[ty][tx] === 1;
  }
  function isFloor(tx,ty){
    return inBounds(tx,ty) && map[ty][tx] === 0;
  }

  function randomFloorFarFrom(px,py,minManhattan){
    for (let i=0;i<900;i++){
      const x = (Math.random()*COLS)|0;
      const y = (Math.random()*ROWS)|0;
      if (!isFloor(x,y)) continue;
      if (Math.abs(x-px)+Math.abs(y-py) < minManhattan) continue;
      return {x,y};
    }
    // fallback scan
    for (let y=1;y<ROWS-1;y++){
      for (let x=1;x<COLS-1;x++){
        if (isFloor(x,y) && Math.abs(x-px)+Math.abs(y-py) >= minManhattan) return {x,y};
      }
    }
    return {x:1,y:1};
  }

  function generateLevel(){
    // Maze (recursive backtracker)
    map = Array(ROWS).fill(0).map(()=>Array(COLS).fill(1));
    const stack = [];
    const start = {x:1,y:1};
    map[start.y][start.x] = 0;
    stack.push(start);
    while (stack.length){
      const c = stack[stack.length-1];
      const dirs = [{dx:0,dy:-2},{dx:0,dy:2},{dx:-2,dy:0},{dx:2,dy:0}].sort(()=>Math.random()-0.5);
      let carved=false;
      for (const d of dirs){
        const nx=c.x+d.dx, ny=c.y+d.dy;
        if (nx>0 && nx<COLS-1 && ny>0 && ny<ROWS-1 && map[ny][nx]===1){
          map[ny][nx]=0;
          map[c.y + d.dy/2][c.x + d.dx/2]=0;
          stack.push({x:nx,y:ny});
          carved=true;
          break;
        }
      }
      if (!carved) stack.pop();
    }

    // Reset hero position / motion
    hero.x=1.5; hero.y=1.5;
    hero.vx=0; hero.vy=0;
    hero.hitCooldown=0;
    hero.sanity=100;
    state.strikes=0;

    // Oxygen base
    hero.maxOxygen = BASE_OXY_SECONDS; // seconds
    hero.oxygen = hero.maxOxygen;

    // Stains
    stains = [];
    const stainCount = 8 + (diff.name==="HELL"?3:0);
    for (let i=0;i<stainCount;i++){
      stains.push(randomFloorFarFrom(1,1,4));
    }

    // Offerings (used in some missions)
    offerings = [];
    while (offerings.length < OFFERINGS_PER_LEVEL){
      const r = randomFloorFarFrom(1,1,6);
      if (offerings.some(o=>o.x===r.x && o.y===r.y)) continue;
      offerings.push({x:r.x,y:r.y, taken:false, order:0});
    }

    // Chests unlock missions
    const chCount = CHESTS_PER_LEVEL_BASE + (diff.name==="HARD"?1:0) + (diff.name==="HELL"?2:0);
    chests = [];
    while (chests.length < chCount){
      const r = randomFloorFarFrom(1,1,5);
      if (chests.some(c=>c.x===r.x && c.y===r.y)) continue;
      if (offerings.some(o=>o.x===r.x && o.y===r.y)) continue;
      chests.push({x:r.x,y:r.y, opened:false});
    }

    // Oxygen tanks
    const tankCount = TANKS_PER_LEVEL_BASE + (diff.name==="HELL"?2:0);
    tanks = [];
    while (tanks.length < tankCount){
      const r = randomFloorFarFrom(1,1,5);
      if (tanks.some(t=>t.x===r.x && t.y===r.y)) continue;
      if (chests.some(c=>c.x===r.x && c.y===r.y)) continue;
      if (offerings.some(o=>o.x===r.x && o.y===r.y)) continue;
      tanks.push({x:r.x,y:r.y, used:false, amount: randi(25,40)}); // seconds
    }

    // Exit locked until mission complete
    exit = randomFloorFarFrom(1,1,12);
    exit.unlocked = false;

    // Mission / prompt / effects reset
    mission.active=false; mission.completed=false;
    prompt.active=false;
    pulse.active=false;
    flash.active=false;
    facePopup.active=false;
    messages = [];
    state.anxiety = 0;
    state.camShake = 0;

    // Spawn monsters
    monsters.length = 0;
    for (let i=0;i<diff.monsters;i++){
      const r = randomFloorFarFrom(1,1,14);
      monsters.push({
        x: r.x+0.5, y: r.y+0.5,
        vx: 0, vy: 0,
        speed: MONSTER_BASE_SPEED * diff.monsterSpeed * rand(0.92, 1.08),
        stun: 0,
        lastHeard: 0,
        target: null,
        stepCooldown: 0,
        aggression: diff.aggression * rand(0.90, 1.15),
        id: i,
      });
    }

    hudStatus.textContent = "STATUS: ALONE";
    hudStatus.className = "pill status";
    pushMessage("BOOT SECTOR OK", "#ffffff");
    pushMessage(pick(cryptic));
    updateHud();
    updateMissionUI();
    updatePromptUI();
  }

  // ========= COLLISION FIX (NO STICKING) =========
  function resolveCircleGrid(px,py){
    let x = px, y = py;

    // Iterative resolution helps with deep overlaps + corner cases
    for (let iter=0; iter<4; iter++){
      let pushed = false;
      const minX = Math.floor(x - PLAYER_R - 1);
      const maxX = Math.floor(x + PLAYER_R + 1);
      const minY = Math.floor(y - PLAYER_R - 1);
      const maxY = Math.floor(y + PLAYER_R + 1);

      for (let ty=minY; ty<=maxY; ty++){
        for (let tx=minX; tx<=maxX; tx++){
          if (!isWall(tx,ty)) continue;

          // tile AABB [tx,tx+1]x[ty,ty+1]
          const cx = Math.max(tx, Math.min(x, tx+1));
          const cy = Math.max(ty, Math.min(y, ty+1));
          const dx = x - cx;
          const dy = y - cy;
          const d2 = dx*dx + dy*dy;

          if (d2 < PLAYER_R*PLAYER_R){
            const d = Math.max(1e-6, Math.sqrt(d2));
            const push = (PLAYER_R - d);
            const nx = dx / d;
            const ny = dy / d;
            x += nx * push;
            y += ny * push;
            pushed = true;
          }
        }
      }
      if (!pushed) break;
    }
    return {x,y};
  }

  // ========= MONSTER AI (tile-guided drift) =========
  function pickMonsterStepToward(mx,my, tx,ty){
    const cx = Math.floor(mx);
    const cy = Math.floor(my);
    const opts = [
      {x:cx+1,y:cy},{x:cx-1,y:cy},{x:cx,y:cy+1},{x:cx,y:cy-1}
    ].filter(p=>isFloor(p.x,p.y));
    if (!opts.length) return null;

    let best = opts[0], bestScore = 1e9;
    for (const o of opts){
      const d = Math.hypot((o.x+0.5)-tx, (o.y+0.5)-ty);
      const wob = (Math.random()-0.5)*0.35;
      const score = d + wob;
      if (score < bestScore){
        bestScore = score;
        best = o;
      }
    }
    return best;
  }

  function updateMonsters(dt){
    // fear based on nearest monster
    let nearest = 999;
    for (const m of monsters){
      const d = Math.hypot(m.x-hero.x, m.y-hero.y);
      if (d < nearest) nearest = d;
    }
    const fear = clamp(1 - nearest/6, 0, 1);
    audio?.setFear?.(fear);

    // faces when very close
    if (nearest < 2.3 && Math.random() < 0.05){
      triggerFacePopup(nearest);
    }

    // monster motion
    const sprinting = !!keys["ShiftLeft"];
    const hear = sprinting ? MONSTER_HEAR_RUN : MONSTER_HEAR_WALK;

    for (const m of monsters){
      if (m.stun > 0){
        m.stun -= dt;
        continue;
      }

      const dx = hero.x - m.x;
      const dy = hero.y - m.y;
      const dist = Math.max(1e-6, Math.hypot(dx,dy));

      // decide target
      let tx = m.x, ty = m.y;
      if (dist < hear){
        m.lastHeard = 1.2;
        tx = hero.x; ty = hero.y;
      } else if (m.lastHeard > 0){
        m.lastHeard -= dt;
        tx = m.x + (dx/dist) * 1.2;
        ty = m.y + (dy/dist) * 1.2;
      } else {
        // drift to stains
        const s = stains[(Math.random()*stains.length)|0];
        tx = s.x+0.5; ty = s.y+0.5;
      }

      m.stepCooldown -= dt;
      if (m.stepCooldown <= 0 || !m.target){
        m.stepCooldown = 0.10 + Math.random()*0.22;
        const step = pickMonsterStepToward(m.x, m.y, tx, ty);
        if (step) m.target = step;
      }

      const spd = m.speed * m.aggression;
      if (m.target){
        const gx = m.target.x+0.5;
        const gy = m.target.y+0.5;
        const mdx = gx - m.x;
        const mdy = gy - m.y;
        const md = Math.max(1e-6, Math.hypot(mdx,mdy));
        m.x += (mdx/md) * spd * dt;
        m.y += (mdy/md) * spd * dt;
        if (md < 0.10) m.stepCooldown = 0;
      }

      // sprint lurch
      if (sprinting && fear>0.45 && Math.random() < 0.0035){
        m.x += (dx/dist)*0.55;
        m.y += (dy/dist)*0.55;
        state.anxiety = Math.max(state.anxiety, 18);
        audio?.blip?.(1.0);
        pushMessage("IMAGE TEAR");
        triggerFlash("tear");
      }

      // hit
      if (hero.hitCooldown > 0) hero.hitCooldown -= dt;
      if (dist < MONSTER_HIT_DIST && hero.hitCooldown <= 0){
        hero.hitCooldown = MONSTER_HIT_COOLDOWN;
        m.stun = 0.28; // brief pause
        state.anxiety = Math.max(state.anxiety, 22);
        state.camShake = Math.max(state.camShake, 12);
        audio?.blip?.(1.0);
        triggerFlash("hit");
        pushMessage("DON'T LOOK", "#ff3355");

        // shove
        hero.x -= (dx/dist)*0.35;
        hero.y -= (dy/dist)*0.35;
        const r = resolveCircleGrid(hero.x, hero.y);
        hero.x = r.x; hero.y = r.y;

        state.strikes++;
        hero.sanity = Math.max(0, hero.sanity - 18);

        if (state.strikes >= STRIKES_TO_DIE){
          dieAndReset();
          return;
        } else {
          hudStatus.textContent = "STATUS: PANICKING";
          hudStatus.className = "pill warn";
          setTimeout(()=>{
            if (state.mode==="PLAY"){
              hudStatus.textContent = mission.active ? "STATUS: MISSION ACTIVE" : "STATUS: WATCHED";
              hudStatus.className = mission.active ? "pill" : "pill warn";
            }
          }, 650);
        }
      }
    }
  }

  function dieAndReset(){
    state.mode = "MENU";
    menu.style.display = "grid";
    loreIntroEl.textContent = "CAUGHT. THE TAPE REWINDS.";
    pushMessage("RESET");
  }

  // ========= OBJECTIVES =========
  function openedChests(){ return chests.filter(c=>c.opened).length; }
  function nearestObjective(){
    // unopened chest -> mission completion stuff -> exit
    let best=null, bestD=1e9;

    for (const c of chests){
      if (c.opened) continue;
      const d = Math.hypot((c.x+0.5)-hero.x, (c.y+0.5)-hero.y);
      if (d<bestD){ bestD=d; best={x:c.x,y:c.y,type:"chest"}; }
    }
    if (best) return best;

    for (const o of offerings){
      if (o.taken) continue;
      const d = Math.hypot((o.x+0.5)-hero.x, (o.y+0.5)-hero.y);
      if (d<bestD){ bestD=d; best={x:o.x,y:o.y,type:"offering"}; }
    }
    if (exit && exit.unlocked){
      const d = Math.hypot((exit.x+0.5)-hero.x, (exit.y+0.5)-hero.y);
      if (d<bestD){ bestD=d; best={x:exit.x,y:exit.y,type:"exit"}; }
    }
    return best;
  }

  // ========= PULSE =========
  function triggerPulse(){
    if (pulse.active) return;
    const obj = nearestObjective();
    if (!obj) return;

    const dx = (obj.x+0.5) - hero.x;
    const dy = (obj.y+0.5) - hero.y;
    const d = Math.max(1e-6, Math.hypot(dx,dy));
    pulse.active = true;
    pulse.t = 0;
    pulse.ring = 0;
    pulse.dirX = dx/d;
    pulse.dirY = dy/d;

    state.anxiety = Math.max(state.anxiety, 10);
    audio?.blip?.(1.0);
    pushMessage("ECHO PULSE", "#ffffff");

    if (mission.active && mission.type === "ECHO_COUNT"){
      mission.extra.used++;
      if (mission.extra.used > mission.extra.max){
        mission.extra.used = 0;
        state.anxiety = Math.max(state.anxiety, 16);
        pushMessage("ECHO OVERFLOW", "#ff3355");
      }
    }
  }

  // ========= MISSIONS (unlocked by chests) =========
  function setMission(m){
    mission.active = true;
    mission.completed = false;
    mission.title = m.title;
    mission.desc = m.desc;
    mission.type = m.type;
    mission.progress = 0;
    mission.goal = m.goal ?? 1;
    mission.extra = m.extra ?? null;

    exit.unlocked = false;

    hudStatus.textContent = "STATUS: MISSION ACTIVE";
    hudStatus.className = "pill";
    pushMessage("NEW TASK LOADED", "#ffffff");
    updateMissionUI();
  }

  function completeMission(){
    mission.completed = true;
    mission.active = false;
    exit.unlocked = true;

    pushMessage("TASK COMPLETE", "#ccffcc");
    pushMessage("EXIT UNSEALED", "#ccffcc");
    audio?.blip?.(1.0);

    hudStatus.textContent = "STATUS: EXIT UNLOCKED";
    hudStatus.className = "pill status";

    // small reward
    state.anxiety = Math.max(0, state.anxiety - 4);
    for (const m of monsters) m.aggression = Math.max(0.92, m.aggression - 0.06);

    updateMissionUI();
  }

  function genMission(){
    // always different missions; scaled by difficulty
    const t = pick(["STILLNESS","NO_RUN","STAIN_TOUCH","ECHO_COUNT","FOLLOW_ORDER","STATIC_PURGE"]);
    const hard = diff.missionHard;

    if (t==="STILLNESS"){
      const sec = clamp(2.0*hard + rand(0.0, 2.2), 2.0, 5.5);
      return {
        type:"STILLNESS",
        title:"STILLNESS RITUAL",
        desc:`Stand still near a stain for ${sec.toFixed(1)}s.\n(Do not move.)`,
        goal: sec,
        extra:{}
      };
    }

    if (t==="NO_RUN"){
      const sec = clamp(10*hard + randi(0,8), 10, 26);
      return {
        type:"NO_RUN",
        title:"SILENT WALK",
        desc:`Survive ${sec.toFixed(0)}s without sprinting.\n(Shift forbidden.)`,
        goal: sec,
        extra:{}
      };
    }

    if (t==="STAIN_TOUCH"){
      const count = clamp(Math.round(2*hard + rand(0,2)), 2, 6);
      return {
        type:"STAIN_TOUCH",
        title:"TOUCH THE CORRUPTION",
        desc:`Step into ${count} different stains.\n(Each stain counts once.)`,
        goal: count,
        extra:{ touched:new Set() }
      };
    }

    if (t==="ECHO_COUNT"){
      const pulses = clamp(Math.round(2*hard + rand(0,2)), 2, 6);
      return {
        type:"ECHO_COUNT",
        title:"ECHO TEST",
        desc:`Use Signal Pulse (E) exactly ${pulses} times.\n(Too many resets.)`,
        goal: pulses,
        extra:{ used:0, max:pulses }
      };
    }

    if (t==="FOLLOW_ORDER"){
      const order = [1,2,3].sort(()=>Math.random()-0.5);
      offerings.forEach((o,i)=>o.order = order[i]);
      return {
        type:"FOLLOW_ORDER",
        title:"SEQUENCE OF OFFERINGS",
        desc:`Collect offerings in the correct sequence.\n(Colors indicate order.)`,
        goal: OFFERINGS_PER_LEVEL,
        extra:{ needed:1 }
      };
    }

    // STATIC_PURGE: stand still while holding breath (oxygen low-ish)
    const sec = clamp(2.5*hard + rand(0,2.8), 2.5, 6.2);
    return {
      type:"STATIC_PURGE",
      title:"STATIC PURGE",
      desc:`When O2 < 40s, stand still for ${sec.toFixed(1)}s.\n(Wait for the tape to clear.)`,
      goal: sec,
      extra:{}
    };
  }

  function updateMission(dt, moving, sprinting){
    if (!mission.active) return;

    if (mission.type==="STILLNESS"){
      const near = stains.some(s => Math.hypot((s.x+0.5)-hero.x, (s.y+0.5)-hero.y) < 2.0);
      if (!moving && near) mission.progress += dt;
      else mission.progress = Math.max(0, mission.progress - dt*0.9);

      if (mission.progress >= mission.goal) completeMission();
      return;
    }

    if (mission.type==="NO_RUN"){
      if (sprinting){
        mission.progress = Math.max(0, mission.progress - dt*2.2);
        state.anxiety = Math.max(state.anxiety, 12);
        if (Math.random()<0.02) pushMessage("TOO LOUD", "#ff3355");
      } else {
        mission.progress += dt;
      }
      if (mission.progress >= mission.goal) completeMission();
      return;
    }

    if (mission.type==="STAIN_TOUCH"){
      for (const s of stains){
        const d = Math.hypot((s.x+0.5)-hero.x, (s.y+0.5)-hero.y);
        if (d < 0.9) mission.extra.touched.add(`${s.x},${s.y}`);
      }
      mission.progress = mission.extra.touched.size;
      if (mission.progress >= mission.goal) completeMission();
      return;
    }

    if (mission.type==="ECHO_COUNT"){
      mission.progress = mission.extra.used;
      if (mission.progress >= mission.goal) completeMission();
      return;
    }

    if (mission.type==="FOLLOW_ORDER"){
      // handled by pickups
      mission.progress = offerings.filter(o=>o.taken).length;
      return;
    }

    if (mission.type==="STATIC_PURGE"){
      const okOxy = hero.oxygen < 40;
      if (okOxy && !moving) mission.progress += dt;
      else mission.progress = Math.max(0, mission.progress - dt*0.9);
      if (!okOxy && Math.random()<0.01) pushMessage("WAIT FOR LOW AIR", "#ffffff");
      if (mission.progress >= mission.goal) completeMission();
      return;
    }
  }

  // ========= PROMPTS (lore choices) =========
  const promptBank = [
    {
      q:`A whisper says: "DO YOU WANT TO BE SEEN, {NAME}?"`,
      a:`1) YES (more clarity)\n2) NO (more safety)`,
      choose:(c)=>{
        if (c===1){
          state.anxiety = Math.max(state.anxiety, 12);
          for (const m of monsters) m.aggression += 0.08;
          pushMessage("YOU ARE VISIBLE", "#ff3355");
        } else {
          for (const m of monsters) m.aggression = Math.max(0.92, m.aggression - 0.07);
          pushMessage("YOU ARE MISSING", "#ffffff");
        }
      }
    },
    {
      q:`The CRT hisses: "SACRIFICE SPEED FOR SILENCE, {NAME}?"`,
      a:`1) ACCEPT\n2) REFUSE`,
      choose:(c)=>{
        if (c===1){
          pushMessage("SILENCE TRADE", "#ffffff");
          state.anxiety = Math.max(0, state.anxiety - 4);
        } else {
          pushMessage("LOUD TRADE", "#ff3355");
          for (const m of monsters) m.aggression += 0.10;
        }
      }
    },
    {
      q:`A stain pulses: "NAME THE COLOR."`,
      a:`1) RED\n2) NONE`,
      choose:(c)=>{
        if (c===1){
          pushMessage("WRONG", "#ff3355");
          state.anxiety = Math.max(state.anxiety, 16);
          triggerFlash("wrong");
        } else {
          pushMessage("CORRECT", "#ccffcc");
          hero.sanity = Math.min(100, hero.sanity + 10);
        }
      }
    },
    {
      q:`A voice counts your breaths: "STOP BREATHING?"`,
      a:`1) STOP\n2) KEEP GOING`,
      choose:(c)=>{
        if (c===1){
          // risky: less oxygen drain briefly, but more fear spikes
          pushMessage("HOLDING", "#ffffff");
          hero.oxygen = Math.min(hero.maxOxygen, hero.oxygen + 6);
          state.anxiety = Math.max(state.anxiety, 14);
        } else {
          pushMessage("GOOD DOG", "#ff3355");
          for (const m of monsters) m.aggression += 0.06;
        }
      }
    }
  ];

  function showPrompt(p){
    if (prompt.active) return;
    prompt.active = true;
    prompt.timer = prompt.maxTime;
    prompt.onChoose = p.choose;

    const name = hero.name.toUpperCase();
    prompt.q = p.q.replaceAll("{NAME}", name);
    prompt.a = p.a;

    pushMessage("INPUT REQUIRED", "#ffffff");
    state.anxiety = Math.max(state.anxiety, 10);
    updatePromptUI();
  }

  function choosePrompt(choice){
    if (!prompt.active) return;
    const fn = prompt.onChoose;
    prompt.active = false;
    prompt.onChoose = null;
    audio?.blip?.(0.9);
    if (fn) fn(choice);
    updatePromptUI();
  }

  function updatePromptUI(){
    promptBox.style.display = prompt.active ? "block" : "none";
    if (!prompt.active) return;
    promptQEl.textContent = prompt.q;
    promptAEl.textContent = prompt.a;
    promptBarEl.style.width = "100%";
  }

  // ========= FLASH / DISTORTION =========
  function proceduralCreepyCanvas(kind=""){
    const c = document.createElement('canvas');
    c.width = 160; c.height = 120;
    const g = c.getContext('2d');

    g.fillStyle="#000"; g.fillRect(0,0,c.width,c.height);

    // grain
    for (let i=0;i<2800;i++){
      const x=(Math.random()*c.width)|0;
      const y=(Math.random()*c.height)|0;
      const v=(Math.random()*70)|0;
      g.fillStyle=`rgb(${v},${v},${v})`;
      g.fillRect(x,y,1,1);
    }

    // abstract face-ish
    const cx = c.width/2 + rand(-14,14);
    const cy = c.height/2 + rand(-10,10);
    g.fillStyle="rgba(255,51,85,0.65)";
    g.fillRect(cx-32, cy-10, 10, 4);
    g.fillRect(cx+22, cy-10, 10, 4);
    g.fillStyle="rgba(0,0,0,0.85)";
    g.fillRect(cx-28, cy-9, 2, 2);
    g.fillRect(cx+26, cy-9, 2, 2);

    g.fillStyle="rgba(255,255,255,0.10)";
    g.fillRect(cx-22, cy+14, 44, 3);

    // tears
    g.fillStyle="rgba(255,51,85,0.20)";
    for (let i=0;i<8;i++){
      const x=cx + rand(-55,55);
      const y=rand(0,c.height);
      g.fillRect(x, y, 1, rand(12,55));
    }

    // smear rows
    g.globalAlpha=0.22;
    for (let i=0;i<7;i++){
      const y=(Math.random()*c.height)|0;
      const dx=rand(-14,14);
      g.drawImage(c, 0, y, c.width, 2, dx, y, c.width, 2);
    }
    g.globalAlpha=1;

    // kind-specific highlight
    if (kind==="hit" || kind==="wrong"){
      g.fillStyle="rgba(255,51,85,0.08)";
      g.fillRect(0,0,c.width,c.height);
    }
    return c;
  }

  function distortDrawImage(img, x, y, w, h, intensity){
    // slice jitter + channel-ish offsets (cheap & creepy)
    const slices = 10 + ((intensity*16)|0);
    for (let i=0;i<slices;i++){
      const sy = (i/slices)*h;
      const sh = h/slices;
      const dx = rand(-1,1) * (2 + intensity*10);
      const dy = rand(-1,1) * (1 + intensity*6);
      const sx = rand(-1,1) * (1 + intensity*4);

      ctx.globalAlpha = 0.55 + Math.random()*0.45;
      ctx.drawImage(img,
        0, sy, img.width, (img.height/slices),
        x + dx + sx, y + sy + dy, w, sh
      );
    }

    // red veil / burn
    ctx.globalAlpha = 0.12 + intensity*0.18;
    ctx.fillStyle = "rgba(255,51,85,1)";
    ctx.fillRect(x,y,w,h);
    ctx.globalAlpha = 1;
  }

  function triggerFlash(kind="pickup"){
    flash.active = true;
    flash.t = 0;
    flash.dur = 0.65 + Math.random()*0.75;
    flash.kind = kind;

    // choose image: your flashes -> else procedural
    if (assets.flashes.length){
      flash.img = pick(assets.flashes);
    } else {
      flash.img = proceduralCreepyCanvas(kind);
    }
    flash.alpha = 0;
  }

  function triggerFacePopup(dist){
    if (facePopup.active) return;
    const img = (Math.random()<0.5 ? assets.face1 : assets.face2);
    facePopup.active = true;
    facePopup.t = 0;
    facePopup.dur = 0.48 + Math.random()*0.35;
    facePopup.img = img || proceduralCreepyCanvas("face");
    facePopup.intensity = clamp(1 - dist/2.3, 0.15, 1);
  }

  // Monster sprite: use your monster image if present, else procedural tiny sprite
  const fallbackMonster = (() => {
    const c = document.createElement('canvas');
    c.width=24; c.height=24;
    const g=c.getContext('2d');
    g.clearRect(0,0,24,24);
    g.fillStyle="rgba(40,40,55,0.92)";
    g.fillRect(6,6,12,12);
    g.fillStyle="rgba(255,51,85,0.85)";
    g.fillRect(9,12,2,1);
    g.fillRect(13,12,2,1);
    g.fillStyle="rgba(0,0,0,0.85)";
    g.fillRect(10,15,4,2);
    for (let i=0;i<30;i++){
      g.fillStyle = Math.random()<0.5 ? "rgba(255,51,85,0.12)" : "rgba(255,255,255,0.08)";
      g.fillRect((Math.random()*24)|0, (Math.random()*24)|0, 1,1);
    }
    return c;
  })();

  // ========= PICKUPS =========
  function openChest(c){
    c.opened = true;
    audio?.thump?.(0.40);
    audio?.blip?.(0.8);
    pushMessage("CHEST OPENED", "#ffffff");

    // chest always causes some visual offense
    if (Math.random() < 0.8) triggerFlash("chest");

    // if no mission active and exit locked -> unlock mission
    if (!mission.active && !exit.unlocked){
      setMission(genMission());
    } else {
      // otherwise likely prompt
      if (Math.random() < 0.7) showPrompt(pick(promptBank));
    }

    updateHud();
    updateMissionUI();
  }

  function collectTank(t){
    t.used = true;
    hero.oxygen = Math.min(hero.maxOxygen, hero.oxygen + t.amount);
    audio?.thump?.(0.28);
    pushMessage(`OXYGEN +${t.amount}s`, "#ccffcc");
    if (Math.random()<0.35) triggerFlash("tank");
    updateHud();
  }

  function collectOffering(o){
    if (mission.active && mission.type==="FOLLOW_ORDER"){
      const needed = mission.extra.needed;
      if (o.order !== needed){
        pushMessage("WRONG SEQUENCE", "#ff3355");
        audio?.blip?.(1.0);
        triggerFlash("wrong");
        // punish: rewind level
        generateLevel();
        return;
      }
      mission.extra.needed = needed + 1;
      if (mission.extra.needed > OFFERINGS_PER_LEVEL){
        completeMission();
      }
    }

    o.taken = true;
    audio?.blip?.(0.95);
    pushMessage("OFFERING ACCEPTED", "#ffffff");
    pushMessage(pick(["FOUND FOOTAGE OK","INDEX CORRUPTED","MEMORY FRAME LOST","AUDIO DESCENDS"]), "#ffffff");

    if (Math.random() < 0.60) triggerFlash("pickup");
    if (Math.random() < 0.30) showPrompt(pick(promptBank));

    updateHud();
  }

  // ========= HUD =========
  function updateHud(){
    hudLeft.textContent = `${hero.name.toUpperCase()} · ${hero.role.toUpperCase()} · STRIKES ${state.strikes}/${STRIKES_TO_DIE}`;
    hudDiff.textContent = `DIFF: ${diff.name}`;
    hudItems.textContent = `CHESTS: ${openedChests()}/${chests.length} · EXIT: ${exit.unlocked ? "OPEN" : "SEALED"}`;

    const oxyPct = clamp(hero.oxygen / hero.maxOxygen, 0, 1);
    hudOxy.textContent = `O2: ${(oxyPct*100)|0}% (${hero.oxygen.toFixed(0)}s)`;

    // warn style
    if (hero.oxygen < LOW_OXY_WARN){
      hudOxy.className = "pill warn";
    } else {
      hudOxy.className = "pill";
    }
  }

  function updateMissionUI(){
    missionBox.style.display = mission.active ? "block" : "none";
    if (!mission.active) return;
    missionTitleEl.textContent = mission.title;
    missionDescEl.textContent = mission.desc;
    const pct = clamp(mission.progress / mission.goal, 0, 1);
    missionBarEl.style.width = `${(pct*100).toFixed(0)}%`;
  }

  // ========= PLAYER DRAW (animated creepy figure) =========
  function drawPlayer(px,py,t){
    // player is screen-centered (camera), so px/py are already camera-space
    const role = hero.role;
    const wob = Math.sin(t*6.2)*0.8 + Math.sin(t*2.1)*0.6;
    const flick = Math.random()<0.20 ? 1 : 0;

    // small trailing smear
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fillRect(px-2 - wob*0.4, py-2 + wob*0.2, 4, 4);
    ctx.globalAlpha = 1;

    if (role==="thief"){
      // thin, angular
      ctx.fillStyle = "#e6eefc";
      ctx.beginPath();
      ctx.moveTo(px, py-5-wob*0.3);
      ctx.lineTo(px+4+wob*0.2, py+4);
      ctx.lineTo(px-4-wob*0.2, py+4);
      ctx.closePath();
      ctx.fill();
      if (flick){
        ctx.fillStyle="rgba(255,51,85,0.35)";
        ctx.fillRect(px-1, py-1, 2, 2);
      }
    } else if (role==="killer"){
      // compact “mask” square with blinking red dot
      ctx.fillStyle = "#f2f2f2";
      ctx.fillRect(px-4, py-4, 8, 8);
      ctx.fillStyle = "rgba(0,0,0,0.85)";
      ctx.fillRect(px-2, py-1, 4, 2);
      ctx.fillStyle = flick ? "rgba(255,51,85,0.85)" : "rgba(255,51,85,0.45)";
      ctx.fillRect(px-1, py-3, 2, 1);
    } else {
      // butcher: heavier, “apron” look
      ctx.fillStyle="#f2f2f2";
      ctx.fillRect(px-4, py-5, 8, 10);
      ctx.fillStyle="rgba(255,51,85,0.45)";
      ctx.fillRect(px-3, py+1, 6, 2);
      ctx.fillStyle="rgba(0,0,0,0.85)";
      ctx.fillRect(px-2, py-2, 4, 1);
      if (flick){
        ctx.fillStyle="rgba(255,51,85,0.25)";
        ctx.fillRect(px-4, py-5, 8, 10);
      }
    }
  }

  // ========= RENDER =========
  function drawNoise(amount){
    if (amount<=0) return;
    ctx.save();
    ctx.globalAlpha = Math.min(0.26, amount/50);
    for (let i=0;i<GRAIN_PARTICLES;i++){
      const x=Math.random()*CAN_W;
      const y=Math.random()*CAN_H;
      const w=1+Math.random()*2;
      const h=1+Math.random()*2;
      ctx.fillStyle = Math.random()<0.5 ? "#0d0d0d" : "#1a1a1a";
      ctx.fillRect(x,y,w,h);
    }
    ctx.restore();
  }

  function render(dt){
    // Clear
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,CAN_W,CAN_H);

    // Determine view radius (fog)
    const viewRadius = clamp(BASE_FOV - (state.anxiety/6)*diff.fog + (pulse.active?2.3:0), MIN_FOV, MAX_FOV);

    // Camera centered on hero + shake
    const shake = Math.min(10, state.camShake + state.anxiety*0.22);
    const shakeX = (Math.random()-0.5)*shake;
    const shakeY = (Math.random()-0.5)*shake;
    const camX = CAN_W/2 - hero.x*TILE + shakeX;
    const camY = CAN_H/2 - hero.y*TILE + shakeY;

    // Tiles
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        const dist = Math.hypot((x+0.5)-hero.x, (y+0.5)-hero.y);
        let vis = 0;
        if (dist < viewRadius){
          vis = 1 - (dist/viewRadius);
          vis = Math.pow(vis, 0.62);
        }

        // pulse ring
        if (pulse.active){
          const ring = pulse.ring;
          const delta = Math.abs(dist - ring);
          if (delta < 1.6){
            vis += 0.55*(1 - delta/1.6);
          }
        }

        if (vis <= 0.01) continue;
        vis = clamp(vis,0,1);

        const sx = camX + x*TILE;
        const sy = camY + y*TILE;

        ctx.save();
        ctx.globalAlpha = vis;

        if (map[y][x]===1){
          ctx.fillStyle = "#333";
          ctx.fillRect(sx,sy,TILE,TILE);
          ctx.strokeStyle = "#1a1a1a";
          ctx.strokeRect(sx,sy,TILE,TILE);
        } else {
          ctx.fillStyle = "#0a0a0a";
          ctx.fillRect(sx,sy,TILE,TILE);

          // stains
          if (stains.some(s=>s.x===x && s.y===y)){
            ctx.fillStyle = `rgba(${120+Math.random()*40|0},0,${40+Math.random()*40|0},0.35)`;
            ctx.fillRect(sx,sy,TILE,TILE);
          }
        }
        ctx.restore();
      }
    }

    // Helper to draw objects (respect visibility)
    function drawObj(tx,ty, color, shape){
      const dist = Math.hypot((tx+0.5)-hero.x, (ty+0.5)-hero.y);
      if (dist > viewRadius && !(pulse.active && Math.abs(dist-pulse.ring)<1.6)) return;

      const sx = camX + tx*TILE;
      const sy = camY + ty*TILE;

      ctx.fillStyle = color;
      if (shape==="box"){
        ctx.fillRect(sx+4, sy+4, 8, 8);
      } else if (shape==="circle"){
        ctx.beginPath();
        ctx.arc(sx+8, sy+8, 4, 0, Math.PI*2);
        ctx.fill();
      } else if (shape==="diamond"){
        ctx.beginPath();
        ctx.moveTo(sx+8, sy+2);
        ctx.lineTo(sx+14, sy+8);
        ctx.lineTo(sx+8, sy+14);
        ctx.lineTo(sx+2, sy+8);
        ctx.closePath();
        ctx.fill();
      }
    }

    // Chests
    for (const c of chests){
      if (!c.opened) drawObj(c.x,c.y,"#4488aa","box");
    }
    // Tanks
    for (const t of tanks){
      if (!t.used) drawObj(t.x,t.y,"#5cf","box");
    }
    // Offerings (color sequence if mission)
    for (const o of offerings){
      if (o.taken) continue;
      if (mission.active && mission.type==="FOLLOW_ORDER"){
        const col = o.order===1 ? "#ff3355" : o.order===2 ? "#55ff88" : "#3388ff";
        drawObj(o.x,o.y,col,"circle");
      } else {
        drawObj(o.x,o.y,"#ddcc44","circle");
      }
    }
    // Exit
    if (exit){
      drawObj(exit.x, exit.y, exit.unlocked ? "#ffffff" : "#550000", "diamond");
      if (exit.unlocked){
        const sx = camX + exit.x*TILE;
        const sy = camY + exit.y*TILE;
        ctx.fillStyle = "rgba(255,51,85,0.65)";
        ctx.fillRect(sx+7, sy+3, 2, TILE-6);
      }
    }

    // Monsters (image sprite following)
    for (const m of monsters){
      const dist = Math.hypot(m.x-hero.x, m.y-hero.y);
      if (dist > viewRadius + 1.6) continue;

      const sx = camX + m.x*TILE - 12;
      const sy = camY + m.y*TILE - 12;

      const img = assets.monster || fallbackMonster;

      // subtle jitter & distortion increases as it approaches
      const intensity = clamp(1 - dist/6, 0, 1);
      const jx = (Math.random()-0.5)*(2 + intensity*4);
      const jy = (Math.random()-0.5)*(2 + intensity*4);

      ctx.save();
      ctx.globalAlpha = 0.72 + intensity*0.25;
      distortDrawImage(img, sx+jx, sy+jy, 24, 24, intensity*0.9);
      ctx.restore();
    }

    // Player at center
    const px = CAN_W/2;
    const py = CAN_H/2;
    drawPlayer(px, py, state.time);

    // Pulse line direction (subtle)
    if (pulse.active){
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = "#ccffcc";
      ctx.beginPath();
      ctx.moveTo(px,py);
      ctx.lineTo(px + pulse.dirX*60, py + pulse.dirY*60);
      ctx.stroke();
      ctx.restore();
    }

    // Flash overlay
    if (flash.active && flash.img){
      const a = flash.alpha * 0.85;
      ctx.save();
      ctx.globalAlpha = a;
      const img = flash.img;
      // if it's an <img> scale to full; if canvas same
      ctx.drawImage(img, 0, 0, CAN_W, CAN_H);
      // extra distortion on top when intense
      if (flash.kind==="hit" || flash.kind==="wrong"){
        ctx.globalAlpha = a*0.45;
        distortDrawImage(img, 0, 0, CAN_W, CAN_H, 0.85);
      }
      ctx.restore();
    }

    // Face popup overlay when near monster
    if (facePopup.active && facePopup.img){
      const a = (1 - (facePopup.t/facePopup.dur)) * 0.95;
      const intensity = facePopup.intensity;

      ctx.save();
      ctx.globalAlpha = a;
      const w = CAN_W;
      const h = CAN_H;
      distortDrawImage(facePopup.img, 0, 0, w, h, intensity);
      ctx.restore();
    }

    // Messages
    ctx.save();
    ctx.font = "18px VT323";
    for (const m of messages){
      ctx.globalAlpha = Math.min(1, m.life/20);
      ctx.fillStyle = m.color;
      ctx.fillText(m.text, m.x, m.y);
    }
    ctx.restore();

    // Noise
    drawNoise(state.anxiety);

    // Prompt bar updates (UI)
    if (prompt.active){
      const pct = clamp(prompt.timer / prompt.maxTime, 0, 1);
      promptBarEl.style.width = `${(pct*100).toFixed(0)}%`;
    }
  }

  // ========= UPDATE LOOP =========
  let last = performance.now();

  function isDown(code){ return !!keys[code]; }

  function update(dt){
    state.time += dt;

    // decay cam shake + anxiety
    state.camShake = Math.max(0, state.camShake - dt*18);
    state.anxiety = Math.max(0, state.anxiety - dt*2.2);

    // prompt timer
    if (prompt.active){
      prompt.timer -= dt;
      if (prompt.timer <= 0){
        prompt.active = false;
        pushMessage("NO RESPONSE", "#ff3355");
        state.anxiety = Math.max(state.anxiety, 14);
        // punish: monsters get bolder
        for (const m of monsters) m.aggression += 0.06;
        updatePromptUI();
      }
    }

    // movement input
    let ix=0, iy=0;
    if (isDown("KeyW") || isDown("ArrowUp")) iy -= 1;
    if (isDown("KeyS") || isDown("ArrowDown")) iy += 1;
    if (isDown("KeyA") || isDown("ArrowLeft")) ix -= 1;
    if (isDown("KeyD") || isDown("ArrowRight")) ix += 1;

    if (ix || iy){
      const len = Math.hypot(ix,iy) || 1;
      ix /= len; iy /= len;
    }

    const sprinting = isDown("ShiftLeft");
    const maxSpd = MAX_SPEED * (sprinting ? RUN_MULT : 1);

    // acceleration
    hero.vx += ix * ACCEL * dt;
    hero.vy += iy * ACCEL * dt;

    // friction (only on axes with no input)
    if (Math.abs(ix) < 0.001){
      const s = Math.sign(hero.vx);
      hero.vx -= s * FRICTION * dt;
      if (Math.sign(hero.vx) !== s) hero.vx = 0;
    }
    if (Math.abs(iy) < 0.001){
      const s = Math.sign(hero.vy);
      hero.vy -= s * FRICTION * dt;
      if (Math.sign(hero.vy) !== s) hero.vy = 0;
    }

    // clamp speed
    const sp = Math.hypot(hero.vx, hero.vy);
    if (sp > maxSpd){
      const k = maxSpd / sp;
      hero.vx *= k; hero.vy *= k;
    }

    // integrate with SUBSTEPS to avoid tunneling + keep collisions stable
    const steps = Math.max(1, Math.min(5, Math.ceil(sp * dt * 3)));
    let nx = hero.x, ny = hero.y;

    for (let s=0; s<steps; s++){
      nx += (hero.vx * dt) / steps;
      ny += (hero.vy * dt) / steps;
      const r = resolveCircleGrid(nx, ny);
      nx = r.x; ny = r.y;
    }

    const moved = (Math.abs(nx-hero.x)+Math.abs(ny-hero.y)) > 1e-5;
    hero.x = nx; hero.y = ny;

    // sprint anxiety + sanity
    if (sprinting && moved){
      state.anxiety = Math.min(26, state.anxiety + dt*9.0);
      hero.sanity = Math.max(0, hero.sanity - dt*10);
    } else {
      hero.sanity = Math.min(100, hero.sanity + dt*6);
    }

    // Oxygen drain (seconds)
    // baseline: maxOxygen / BASE_OXY_SECONDS_per_full = 1 sec/sec -> so oxygen is "seconds remaining"
    const drain = (1.0 * diff.oxygenDrain) * (sprinting ? RUN_OXY_MULT : 1.0);
    hero.oxygen = Math.max(0, hero.oxygen - drain*dt);

    audio?.setOxy?.(hero.oxygen / hero.maxOxygen);

    // oxygen panic pressure but not instant death
    if (hero.oxygen <= 0){
      // suffocation is a loss (but not hyper-frenetic)
      pushMessage("NO AIR", "#ff3355");
      dieAndReset();
      return;
    } else if (hero.oxygen < LOW_OXY_WARN){
      state.anxiety = Math.max(state.anxiety, 10);
      if (Math.random()<0.015) pushMessage(`${hero.name.toUpperCase()} CAN'T BREATHE`, "#ff3355");
    }

    // Pulse update
    if (pulse.active){
      pulse.t += dt * 10.5;
      pulse.ring = pulse.t * 2.2;
      if (pulse.t > 2.8) pulse.active = false;
    }

    // flash update
    if (flash.active){
      flash.t += dt;
      if (flash.t < flash.dur*0.2) flash.alpha = flash.t/(flash.dur*0.2);
      else flash.alpha = 1 - (flash.t - flash.dur*0.2)/(flash.dur*0.8);
      if (flash.t >= flash.dur){
        flash.active = false;
        flash.alpha = 0;
      }
    }

    // face popup update
    if (facePopup.active){
      facePopup.t += dt;
      if (facePopup.t >= facePopup.dur){
        facePopup.active = false;
      }
    }

    // stains influence
    for (const st of stains){
      const d = Math.hypot((st.x+0.5)-hero.x, (st.y+0.5)-hero.y);
      if (d < 1.0){
        state.anxiety = Math.max(state.anxiety, 8);
        if (Math.random()<0.012) pushMessage("COLOR BLEED", "#ffffff");
        if (Math.random()<0.006) audio?.blip?.(0.35);
        if (!prompt.active && Math.random()<0.004) showPrompt(pick(promptBank));
      }
    }

    // pickups: chests
    for (const c of chests){
      if (c.opened) continue;
      const d = Math.hypot((c.x+0.5)-hero.x, (c.y+0.5)-hero.y);
      if (d < 0.75) openChest(c);
    }

    // tanks
    for (const t of tanks){
      if (t.used) continue;
      const d = Math.hypot((t.x+0.5)-hero.x, (t.y+0.5)-hero.y);
      if (d < 0.75) collectTank(t);
    }

    // offerings
    for (const o of offerings){
      if (o.taken) continue;
      const d = Math.hypot((o.x+0.5)-hero.x, (o.y+0.5)-hero.y);
      if (d < 0.75) collectOffering(o);
    }

    // mission update
    updateMission(dt, moved, sprinting);

    // chance of lore prompt on milestones
    if (!prompt.active && (openedChests()===2 || offerings.filter(o=>o.taken).length===2) && Math.random()<0.01){
      showPrompt(pick(promptBank));
    }

    // update monsters
    updateMonsters(dt);

    // objective panning
    const obj = nearestObjective();
    if (obj && audio){
      const dx = (obj.x+0.5) - hero.x;
      audio.setObjectivePan(dx/6);
    }

    // Exit check
    if (exit.unlocked){
      const d = Math.hypot((exit.x+0.5)-hero.x, (exit.y+0.5)-hero.y);
      if (d < 0.62){
        // descend: new level, difficulty reroll slight drift
        pushMessage("DESCENDING...", "#ccffcc");
        audio?.blip?.(1.0);
        generateLevel();
      }
    }

    // message decay
    for (let i=messages.length-1; i>=0; i--){
      messages[i].life -= 1;
      if (messages[i].life <= 0) messages.splice(i,1);
    }

    // Update HUD/mission UI
    updateHud();
    if (mission.active) updateMissionUI();
  }

  function loop(){
    const now = performance.now();
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    if (state.mode==="PLAY"){
      update(dt);
      render(dt);
    } else {
      // idle visuals behind menu: slow noise + faint flicker
      ctx.fillStyle="#000";
      ctx.fillRect(0,0,CAN_W,CAN_H);
      state.time += dt;
      state.anxiety = 6 + Math.sin(state.time*1.5)*2;
      drawNoise(state.anxiety);
    }

    // clear justPressed
    for (const k in justPressed) delete justPressed[k];

    requestAnimationFrame(loop);
  }

  // ========= MENU START (does not start from input clicks) =========
  async function startGameFromMenu(){
    // ONLY this function starts the game
    hero.name = (nameInput.value || "UNKNOWN").trim().slice(0,18) || "UNKNOWN";
    hero.role = roleSelect.value;

    rollDifficulty();

    loreIntroEl.textContent = randomLoreIntro(hero.name, hero.role);

    // lock menu off and start
    await ensureAudio();
    state.mode="PLAY";
    menu.style.display="none";

    // per-role micro stat flavor (kept subtle)
    if (hero.role==="thief"){
      // slightly faster walk, slightly less oxygen bonus
      // (still >= 60s baseline)
      // keep within safe envelope
    } else if (hero.role==="killer"){
      // a bit more fear spikes
      state.anxiety = Math.max(state.anxiety, 4);
    } else {
      // butcher: slightly more oxygen tank value? handled in pickups (not needed)
    }

    generateLevel();

    // immediate mission is NOT forced; player opens chests for missions (as requested)
    pushMessage(`HELLO, ${hero.name.toUpperCase()}`, "#ccffcc");
    updateHud();
  }

  startBtn.addEventListener("click", (e)=>{
    e.preventDefault();
    e.stopPropagation();
    startGameFromMenu();
  });

  // Ensure clicks on inputs never start game (they won’t, by design)
  nameInput.addEventListener("pointerdown", e=>e.stopPropagation());
  roleSelect.addEventListener("pointerdown", e=>e.stopPropagation());

  // ========= BOOT =========
  (async () => {
    // Load assets in background (no blocking)
    loadAssets();

    // initial menu lore (random, non-starting)
    loreIntroEl.textContent = "TYPE A NAME. CHOOSE A ROLE. PRESS START.\nTHE TAPE IS ALREADY RUNNING.";

    // Start loop
    requestAnimationFrame(loop);
  })();

})();
</script>
</body>
</html>




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>ENTROPY.DAT</title>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  
  <style>
    /* --- CSS STYLES --- */
    body {
      background-color: #050505;
      color: #a8b5b2;
      font-family: 'VT323', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      overflow: hidden;
      user-select: none; /* Prevent highlighting text while playing */
    }

    .crt-monitor {
      position: relative;
      border: 1px solid #333;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
      width: 640px;
      height: 480px;
      background: #000;
    }

    canvas {
      width: 100%;
      height: 100%;
      background-color: #000;
      display: block;
      image-rendering: pixelated;
    }

    /* scanlines overlay */
    .scanlines {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(
        to bottom,
        rgba(255,255,255,0),
        rgba(255,255,255,0) 50%,
        rgba(0,0,0,0.22) 50%,
        rgba(0,0,0,0.22)
      );
      background-size: 100% 4px;
      pointer-events: none;
      z-index: 10;
    }

    /* subtle flicker */
    .crt-monitor::after {
      content: " ";
      display: block;
      position: absolute;
      top: 0; left: 0; bottom: 0; right: 0;
      background: rgba(18, 16, 16, 0.10);
      opacity: 0;
      z-index: 10;
      pointer-events: none;
      animation: flicker 0.14s infinite;
    }

    @keyframes flicker {
      0% { opacity: 0.02; }
      50% { opacity: 0.06; }
      100% { opacity: 0.02; }
    }

    #game-ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      z-index: 20;
      color: #ccffcc;
      text-shadow: 0 0 5px #ccffcc;
      font-size: 1.5rem;
      pointer-events: none;
    }

    .controls-hint {
      margin-top: 20px;
      text-align: center;
      opacity: 0.55;
      font-size: 1.2rem;
    }

    .start-overlay {
      position: absolute;
      inset: 0;
      z-index: 30;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at center, rgba(0,0,0,0.35), rgba(0,0,0,0.92));
      color: #ccffcc;
      text-shadow: 0 0 8px rgba(204,255,204,0.35);
      cursor: pointer;
    }

    .start-overlay:focus {
      outline: 2px solid rgba(204,255,204,0.35);
      outline-offset: -6px;
    }

    .start-overlay .start-title {
      font-size: 4rem;
      letter-spacing: 2px;
      margin-bottom: 10px;
      text-align: center;
    }

    .start-overlay .start-sub {
      font-size: 1.8rem;
      opacity: 0.9;
      text-align: center;
    }

    .start-overlay .small {
      font-size: 1.2rem;
      opacity: 0.65;
    }
  </style>
</head>
<body>

  <div class="crt-monitor" id="crt">
    <div class="scanlines"></div>

    <div id="game-ui">
      <span id="score-display">OFFERINGS: 0/3</span>
      <span id="status-display">STATUS: ALONE</span>
    </div>

    <canvas id="gameCanvas" width="320" height="240"></canvas>

    <div id="startOverlay" class="start-overlay" tabindex="0" role="button" aria-label="Start game">
      <div>
        <div class="start-title">ENTROPY.DAT</div>
        <div class="start-sub">CLICK TO INITIALIZE</div>
        <div class="start-sub small">WASD / Arrows to move · Shift to run (louder)</div>
        <div class="start-sub small">Find offerings. Follow instructions. Escape.</div>
      </div>
    </div>
  </div>

  <div class="controls-hint">
    WASD / Arrows to Move · Shift to Run (makes you easier to track).<br/>
    The stalker isn’t your enemy. It’s your <i>clock</i>.
  </div>

  <script>
    // --- JAVASCRIPT LOGIC ---
    
    // --- CONFIGURATION ---
    const TILE_SIZE = 16;
    const COLS = 20;
    const ROWS = 15;
    const FOV_RADIUS = 6;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    const statusDisplay = document.getElementById('status-display');
    const scoreDisplay = document.getElementById('score-display');
    const startOverlay = document.getElementById('startOverlay');

    // --- GAME STATE ---
    let map = [];
    let keys = {};
    let player = { x: 1, y: 1, speed: 0.08, panicHits: 0, panicGrace: 0 };
    let offerings = [];
    let collectedCount = 0;
    const TOTAL_OFFERINGS = 3;
    let exit = null;
    let enemy = { x: -1, y: -1, active: false, speed: 0.022, stun: 0, drift: 0, lastSeen: 0 };
    let messages = [];
    let globalAnxiety = 0;

    let mission = { type: "TUNE", progress: 0, target: 2.0 };
    let gameStarted = false;

    // “sound” phrases
    const crypticPhrases = [
      "IT KNOWS", "BEHIND YOU", "NULL REFERENCE",
      "WHERE AM I", "DONT STOP", "STATIC...", "1997",
      "DE-SYNC", "LOST SIGNAL", "FRAME DROP", "NO CLIP"
    ];

    // --- INPUT ---
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (!gameStarted && (e.code === "Enter" || e.code === "Space")) startGame();
    }, { passive: true });

    window.addEventListener('keyup', (e) => keys[e.code] = false, { passive: true });

    // --- AUDIO (Ever-changing, eerie, non-repeating) ---
    let audio = null;

    function initAudio() {
      if (audio) return;

      const AC = window.AudioContext || window.webkitAudioContext;
      const ac = new AC();

      const master = ac.createGain();
      master.gain.value = 0.65;
      master.connect(ac.destination);

      // noise buffer
      const noiseBuf = ac.createBuffer(1, ac.sampleRate * 2, ac.sampleRate);
      {
        const d = noiseBuf.getChannelData(0);
        let last = 0;
        for (let i = 0; i < d.length; i++) {
          last = 0.97 * last + 0.03 * (Math.random() * 2 - 1);
          d[i] = last;
        }
      }

      // wind bed
      const wind = ac.createBufferSource();
      wind.buffer = noiseBuf;
      wind.loop = true;

      const windLP = ac.createBiquadFilter();
      windLP.type = "lowpass";
      windLP.frequency.value = 220;

      const windGain = ac.createGain();
      windGain.gain.value = 0.05;

      wind.connect(windLP);
      windLP.connect(windGain);
      windGain.connect(master);
      wind.start();

      // radio static
      const staticSrc = ac.createBufferSource();
      staticSrc.buffer = noiseBuf;
      staticSrc.loop = true;

      const staticBP = ac.createBiquadFilter();
      staticBP.type = "bandpass";
      staticBP.frequency.value = 1300;
      staticBP.Q.value = 0.8;

      const staticGain = ac.createGain();
      staticGain.gain.value = 0.02;

      staticSrc.connect(staticBP);
      staticBP.connect(staticGain);
      staticGain.connect(master);
      staticSrc.start();

      // drone
      const drone = ac.createOscillator();
      drone.type = "sine";
      drone.frequency.value = 55;

      const mod = ac.createOscillator();
      mod.type = "sine";
      mod.frequency.value = 0.12;

      const modGain = ac.createGain();
      modGain.gain.value = 18;
      mod.connect(modGain);
      modGain.connect(drone.frequency);

      const droneLP = ac.createBiquadFilter();
      droneLP.type = "lowpass";
      droneLP.frequency.value = 520;

      const droneGain = ac.createGain();
      droneGain.gain.value = 0.03;

      drone.connect(droneLP);
      droneLP.connect(droneGain);
      droneGain.connect(master);

      drone.start();
      mod.start();

      function blip(intensity = 0.4) {
        const t = ac.currentTime;

        const o = ac.createOscillator();
        o.type = Math.random() < 0.5 ? "square" : "triangle";
        o.frequency.value = 120 + Math.random() * 1600;

        const bp = ac.createBiquadFilter();
        bp.type = "bandpass";
        bp.frequency.value = 400 + Math.random() * 2800;
        bp.Q.value = 8;

        const g = ac.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.09 * intensity, t + 0.002);
        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.08);

        o.connect(bp);
        bp.connect(g);
        g.connect(master);

        o.start(t);
        o.stop(t + 0.09);
      }

      function eventTick() {
        const fear = audio?.fear ?? 0;
        if (Math.random() < 0.18 + fear * 0.25) blip(0.2 + Math.random() * (0.4 + fear));
        setTimeout(eventTick, 220 + Math.random() * (900 - fear * 400));
      }

      function mutate() {
        const t = ac.currentTime;

        staticBP.frequency.setTargetAtTime(700 + Math.random() * 3000, t, 1.8);
        staticGain.gain.setTargetAtTime(0.012 + Math.random() * 0.03, t, 1.2);
        windLP.frequency.setTargetAtTime(120 + Math.random() * 320, t, 2.5);

        drone.frequency.setTargetAtTime(35 + Math.random() * 55, t, 2.0);
        droneLP.frequency.setTargetAtTime(250 + Math.random() * 900, t, 2.0);
        droneGain.gain.setTargetAtTime(0.018 + Math.random() * 0.06, t, 2.0);

        if (Math.random() < 0.12) {
          drone.detune.setTargetAtTime((Math.random() < 0.5 ? -1 : 1) * (80 + Math.random() * 180), t, 0.6);
          setTimeout(() => drone.detune.setTargetAtTime(0, ac.currentTime, 0.9), 900 + Math.random() * 1400);
        }

        setTimeout(mutate, 900 + Math.random() * 1600);
      }

      audio = {
        ac,
        fear: 0,
        blip,
        setFear(f) {
          audio.fear = f;
          const t = ac.currentTime;
          staticGain.gain.setTargetAtTime(0.015 + f * 0.10, t, 0.08);
          staticBP.Q.setTargetAtTime(0.8 + f * 9, t, 0.15);
          windGain.gain.setTargetAtTime(0.04 + f * 0.08, t, 0.12);
          droneGain.gain.setTargetAtTime(0.02 + f * 0.09, t, 0.2);
          if (f > 0.68 && Math.random() < 0.10) blip(0.7 * f);
        }
      };

      setTimeout(mutate, 500);
      setTimeout(eventTick, 800);
    }

    async function ensureAudioRunning() {
      initAudio();
      if (audio?.ac?.state === "suspended") {
        try { await audio.ac.resume(); } catch {}
      }
    }

    // --- START FIX: bind start to OVERLAY + canvas + document ---
    function bindStartHandlers() {
      const startFromGesture = async (e) => {
        e?.preventDefault?.();
        e?.stopPropagation?.();
        if (!gameStarted) startGame();
      };

      // overlay catches clicks (since it's above canvas)
      if (startOverlay) {
        startOverlay.addEventListener("pointerdown", startFromGesture);
        startOverlay.addEventListener("click", startFromGesture);
      }

      // canvas still works (if overlay is gone)
      canvas.addEventListener("pointerdown", startFromGesture);

      // keydown already starts via window listener above; ensure first key also unlocks audio
      window.addEventListener("keydown", () => ensureAudioRunning(), { once: true });
    }
    bindStartHandlers();

    // --- MAP GENERATION ---
    function generateLevel() {
      map = Array(ROWS).fill(0).map(() => Array(COLS).fill(1));

      const stack = [];
      const start = { x: 1, y: 1 };
      map[start.y][start.x] = 0;
      stack.push(start);

      while (stack.length > 0) {
        const current = stack[stack.length - 1];
        const directions = [
          { dx: 0, dy: -2 }, { dx: 0, dy: 2 },
          { dx: -2, dy: 0 }, { dx: 2, dy: 0 }
        ].sort(() => Math.random() - 0.5);

        let carved = false;
        for (let dir of directions) {
          const nx = current.x + dir.dx;
          const ny = current.y + dir.dy;
          if (nx > 0 && nx < COLS - 1 && ny > 0 && ny < ROWS - 1 && map[ny][nx] === 1) {
            map[ny][nx] = 0;
            map[current.y + (dir.dy / 2)][current.x + (dir.dx / 2)] = 0;
            stack.push({ x: nx, y: ny });
            carved = true;
            break;
          }
        }
        if (!carved) stack.pop();
      }

      offerings = [];
      while (offerings.length < TOTAL_OFFERINGS) {
        const rx = Math.floor(Math.random() * COLS);
        const ry = Math.floor(Math.random() * ROWS);
        if (map[ry][rx] === 0 && (Math.abs(rx - 1) + Math.abs(ry - 1) > 5)) {
          offerings.push({ x: rx, y: ry, collected: false, order: 0 });
        }
      }

      player.x = 1; player.y = 1;
      player.panicHits = 0;
      player.panicGrace = 0;

      collectedCount = 0;
      exit = null;

      enemy.active = false;
      enemy.stun = 0;
      enemy.lastSeen = 0;
      enemy.drift = 0;
      enemy.speed = 0.022;

      globalAnxiety = 0;
      messages = [];

      const types = ["TUNE", "NO_RUN", "ORDER"];
      mission.type = types[Math.floor(Math.random() * types.length)];
      mission.progress = 0;
      mission.target = 2.0;

      if (mission.type === "ORDER") {
        const order = [1, 2, 3].sort(() => Math.random() - 0.5);
        offerings.forEach((o, i) => o.order = order[i]);
      }

      statusDisplay.style.color = "#ccffcc";
      statusDisplay.innerText =
        mission.type === "TUNE" ? "STATUS: FIND SIGNAL" :
        mission.type === "NO_RUN" ? "STATUS: DO NOT RUN" :
        "STATUS: FOLLOW ORDER";

      updateUI();
    }

    // --- COLLISION ---
    function checkWall(x, y) {
      return map[Math.floor(y + 0.2)][Math.floor(x + 0.2)] === 1 ||
             map[Math.floor(y + 0.8)][Math.floor(x + 0.2)] === 1 ||
             map[Math.floor(y + 0.2)][Math.floor(x + 0.8)] === 1 ||
             map[Math.floor(y + 0.8)][Math.floor(x + 0.8)] === 1;
    }

    // --- MESSAGES ---
    function triggerMessage(text = null) {
      if (Math.random() > 0.35 && !text) return;
      const phrase = text || crypticPhrases[Math.floor(Math.random() * crypticPhrases.length)];
      messages.push({
        text: phrase,
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        life: 55,
        color: Math.random() > 0.5 ? '#ff2244' : '#ffffff'
      });
    }

    function updateUI() {
      scoreDisplay.innerText = `OFFERINGS: ${collectedCount}/${TOTAL_OFFERINGS}`;
    }

    // --- EXIT ---
    function spawnExit() {
      let tries = 0;
      while (!exit && tries++ < 2000) {
        const rx = Math.floor(Math.random() * COLS);
        const ry = Math.floor(Math.random() * ROWS);
        if (map[ry][rx] === 0 && (Math.abs(rx - 1) + Math.abs(ry - 1) > 8)) {
          exit = { x: rx, y: ry };
        }
      }
      if (!exit) exit = { x: COLS - 2, y: ROWS - 2 };
      triggerMessage("THE WAY IS OPEN");
      audio?.blip?.(0.8);
    }

    // --- ENEMY (Winnable stalker) ---
    function updateEnemy() {
      if (collectedCount >= 1 && !enemy.active) {
        enemy.active = true;
        enemy.x = COLS - 2;
        enemy.y = ROWS - 2;
        statusDisplay.innerText = "STATUS: WATCHED";
        statusDisplay.style.color = "#ff3344";
        audio?.blip?.(0.9);
      }
      if (!enemy.active) return;

      const dx = player.x - enemy.x;
      const dy = player.y - enemy.y;
      const dist = Math.max(0.0001, Math.sqrt(dx * dx + dy * dy));

      if (enemy.stun > 0) {
        enemy.stun -= 1;
        audio?.setFear?.(Math.max(0, 1 - dist / 7));
        return;
      }

      const sprinting = !!keys["ShiftLeft"];
      const hearRadius = sprinting ? 7.5 : 4.5;

      if (dist < 3) {
        globalAnxiety = Math.max(globalAnxiety, 9 + (3 - dist) * 6);
        if (Math.random() < 0.06) triggerMessage();
      }

      audio?.setFear?.(Math.max(0, Math.min(1, 1 - dist / 6)));

      let tx = enemy.x, ty = enemy.y;

      if (dist < hearRadius) {
        enemy.lastSeen = 60;
        tx = player.x; ty = player.y;
      } else if (enemy.lastSeen > 0) {
        enemy.lastSeen--;
        tx = enemy.x + (dx / dist) * 0.8;
        ty = enemy.y + (dy / dist) * 0.8;
      } else {
        enemy.drift -= 1;
        if (enemy.drift <= 0) {
          enemy.drift = 30 + Math.floor(Math.random() * 80);
          tx = enemy.x + (Math.random() * 2 - 1) * 3;
          ty = enemy.y + (Math.random() * 2 - 1) * 3;
        }
      }

      const step = enemy.speed;
      const ndx = tx - enemy.x;
      const ndy = ty - enemy.y;
      const nd = Math.max(0.0001, Math.sqrt(ndx * ndx + ndy * ndy));

      const ex = enemy.x + (ndx / nd) * step;
      const ey = enemy.y + (ndy / nd) * step;

      if (!checkWall(ex, enemy.y)) enemy.x = ex;
      if (!checkWall(enemy.x, ey)) enemy.y = ey;

      if (player.panicGrace > 0) player.panicGrace -= 1;

      if (dist < 0.55 && player.panicGrace <= 0) {
        player.panicGrace = 55;
        enemy.stun = 45;

        globalAnxiety = Math.max(globalAnxiety, 22);
        triggerMessage("DON'T LOOK");
        audio?.blip?.(1.0);

        player.x -= (dx / dist) * 0.35;
        player.y -= (dy / dist) * 0.35;

        player.panicHits += 1;
        if (player.panicHits >= 2) {
          alert("CAUGHT. RESETTING.");
          generateLevel();
          return;
        } else {
          statusDisplay.innerText = "STATUS: PANICKING";
          setTimeout(() => {
            statusDisplay.innerText = "STATUS: WATCHED";
            statusDisplay.style.color = "#ff3344";
          }, 900);
        }
      }

      if (player.panicHits > 0 && dist > 4.5) {
        player.panicHits = Math.max(0, player.panicHits - 0.0025);
      }
    }

    // --- LIGHTWEIGHT NOISE OVERLAY ---
    function drawNoiseOverlay(amount) {
      if (amount <= 0) return;
      ctx.save();
      ctx.globalAlpha = Math.min(0.22, amount / 50);
      for (let i = 0; i < 150; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const w = 1 + Math.random() * 2;
        const h = 1 + Math.random() * 2;
        ctx.fillStyle = Math.random() < 0.5 ? "#0d0d0d" : "#1a1a1a";
        ctx.fillRect(x, y, w, h);
      }
      ctx.restore();
    }

    // --- UPDATE LOOP ---
    function update() {
      let vx = 0, vy = 0;
      let currentSpeed = player.speed;
      const sprinting = !!keys["ShiftLeft"];

      if (sprinting) {
        currentSpeed *= 1.5;
        globalAnxiety = Math.min(globalAnxiety + 0.35, 14);
      } else {
        globalAnxiety = Math.max(globalAnxiety - 0.12, 0);
      }

      if (keys['KeyW'] || keys['ArrowUp']) vy = -currentSpeed;
      if (keys['KeyS'] || keys['ArrowDown']) vy = currentSpeed;
      if (keys['KeyA'] || keys['ArrowLeft']) vx = -currentSpeed;
      if (keys['KeyD'] || keys['ArrowRight']) vx = currentSpeed;

      const nextX = player.x + vx;
      const nextY = player.y + vy;

      if (!checkWall(nextX, player.y)) player.x = nextX;
      if (!checkWall(player.x, nextY)) player.y = nextY;

      const moving = Math.abs(vx) + Math.abs(vy) > 0.00001;

      // mission: TUNE
      if (mission.type === "TUNE") {
        const nearSignal = offerings.some(o => !o.collected && Math.hypot(player.x - o.x, player.y - o.y) < 2.2);
        if (!moving && nearSignal) {
          mission.progress += 1 / 60;
          if (mission.progress > mission.target) {
            triggerMessage("SIGNAL LOCKED");
            mission.type = "DONE";
            enemy.stun = 120;
            audio?.blip?.(1.0);
            statusDisplay.innerText = "STATUS: SIGNAL LOCKED";
            statusDisplay.style.color = "#ccffcc";
          } else if (Math.random() < 0.02) {
            triggerMessage("HOLD STILL");
          }
        } else {
          mission.progress = Math.max(0, mission.progress - 0.05);
        }
      }

      updateEnemy();

      // pickups
      offerings.forEach(o => {
        if (o.collected) return;
        const d = Math.hypot(player.x - o.x, player.y - o.y);
        if (d < 0.5) {
          if (mission.type === "NO_RUN" && sprinting) {
            triggerMessage("TOO LOUD");
            globalAnxiety = Math.max(globalAnxiety, 14);
            audio?.blip?.(0.5);
            return;
          }

          if (mission.type === "ORDER") {
            const needed = collectedCount + 1;
            if (o.order !== needed) {
              triggerMessage("WRONG SEQUENCE");
              globalAnxiety = Math.max(globalAnxiety, 18);
              audio?.blip?.(1.0);
              generateLevel();
              return;
            }
          }

          o.collected = true;
          collectedCount++;
          triggerMessage("OFFERING ACCEPTED");
          audio?.blip?.(0.9);
          updateUI();

          if (collectedCount === TOTAL_OFFERINGS) spawnExit();
        }
      });

      if (exit) {
        const d = Math.hypot(player.x - exit.x, player.y - exit.y);
        if (d < 0.5) {
          alert("DESCENDING DEEPER...");
          generateLevel();
        }
      }

      messages = messages.filter(m => m.life > 0);
      messages.forEach(m => m.life--);

      globalAnxiety = Math.min(globalAnxiety, 26);
    }

    // --- RENDERING ---
    function draw() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.save();

      const shake = Math.min(9, globalAnxiety);
      const shakeX = (Math.random() - 0.5) * shake;
      const shakeY = (Math.random() - 0.5) * shake;

      const camX = -player.x * TILE_SIZE + canvas.width / 2;
      const camY = -player.y * TILE_SIZE + canvas.height / 2;
      ctx.translate(camX + shakeX, camY + shakeY);

      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const distToPlayer = Math.hypot(x - player.x, y - player.y);
          if (distToPlayer > FOV_RADIUS) continue;

          const v = Math.max(0, Math.min(1, 1 - distToPlayer / FOV_RADIUS));

          if (map[y][x] === 1) {
            ctx.fillStyle = `rgba(50,52,62,${v})`;
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          } else {
            ctx.fillStyle = `rgba(18,18,24,${v})`;
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }
      }

      offerings.forEach(o => {
        if (o.collected) return;
        const distToPlayer = Math.hypot(o.x - player.x, o.y - player.y);
        if (distToPlayer > FOV_RADIUS) return;

        const pulse = 0.55 + Math.sin(Date.now() / 220) * 0.25;
        let col = `rgba(200,200,120,${pulse})`;

        if (mission.type === "ORDER") {
          col = o.order === 1 ? `rgba(210,160,90,${pulse})`
              : o.order === 2 ? `rgba(170,210,120,${pulse})`
              : `rgba(210,120,150,${pulse})`;
        }

        ctx.fillStyle = col;
        ctx.fillRect(o.x * TILE_SIZE + 4, o.y * TILE_SIZE + 4, 8, 8);
      });

      if (exit) {
        const distToPlayer = Math.hypot(exit.x - player.x, exit.y - player.y);
        if (distToPlayer <= FOV_RADIUS + 0.5) {
          ctx.fillStyle = "rgba(255,255,255,0.95)";
          ctx.fillRect(exit.x * TILE_SIZE, exit.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.fillStyle = "rgba(255,60,90,0.7)";
          ctx.fillRect(exit.x * TILE_SIZE + 7, exit.y * TILE_SIZE + 3, 2, TILE_SIZE - 6);
        }
      }

      if (enemy.active) {
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        if (dist < FOV_RADIUS - 0.5 && Math.random() < 0.55) {
          ctx.fillStyle = "rgba(255, 0, 60, 0.22)";
          ctx.fillRect(enemy.x * TILE_SIZE, enemy.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }

      ctx.fillStyle = "#88AAFF";
      const px = player.x * TILE_SIZE + TILE_SIZE / 2;
      const py = player.y * TILE_SIZE + TILE_SIZE / 2;
      ctx.beginPath();
      ctx.arc(px, py, 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      ctx.font = "20px 'VT323', monospace";
      messages.forEach(m => {
        ctx.fillStyle = m.color;
        ctx.fillText(m.text, m.x, m.y);
      });

      drawNoiseOverlay(globalAnxiety);
    }

    // --- LOOP ---
    function gameLoop() {
      if (gameStarted) {
        update();
        draw();
      } else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawNoiseOverlay(6);
      }
      requestAnimationFrame(gameLoop);
    }

    // --- START ---
    async function startGame() {
      if (gameStarted) return;
      gameStarted = true;

      // hide overlay safely
      if (startOverlay && startOverlay.style) startOverlay.style.display = "none";

      // unlock audio + start level
      await ensureAudioRunning();
      generateLevel();
    }

    // Boot
    generateLevel();
    gameLoop();
  </script>
</body>
</html>


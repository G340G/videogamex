<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>ENTROPY.DAT</title>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

  <style>
    :root{
      --fg:#cfe2da;
      --green:#ccffcc;
      --red:#ff3355;
      --bg:#050505;
    }
    body{
      background:var(--bg); color:var(--fg); font-family:'VT323',monospace;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      height:100vh; margin:0; overflow:hidden; user-select:none;
    }
    .crt-monitor{
      position:relative; border:1px solid #333; box-shadow:0 0 20px rgba(0,0,0,.8);
      width:640px; height:480px; background:#000;
    }
    canvas{
      width:100%; height:100%; background:#000; display:block; image-rendering:pixelated;
    }
    .scanlines{
      position:absolute; inset:0;
      background:linear-gradient(to bottom,
        rgba(255,255,255,0),
        rgba(255,255,255,0) 50%,
        rgba(0,0,0,.22) 50%,
        rgba(0,0,0,.22)
      );
      background-size:100% 4px; pointer-events:none; z-index:10;
    }
    .crt-monitor::after{
      content:" "; position:absolute; inset:0;
      background:rgba(18,16,16,.10); opacity:0; z-index:10; pointer-events:none;
      animation:flicker .14s infinite;
    }
    @keyframes flicker{0%{opacity:.02}50%{opacity:.06}100%{opacity:.02}}

    /* Small HUD so it doesn't cover view */
    #hud{
      position:absolute; top:8px; left:8px;
      z-index:20; pointer-events:none;
      color:var(--green); text-shadow:0 0 5px rgba(204,255,204,.6);
      font-size:1.1rem; line-height:1.05;
      background:rgba(0,0,0,0.35);
      padding:6px 8px; border:1px solid rgba(204,255,204,.22);
      border-radius:4px;
      max-width:165px;
    }
    #hud .dim{opacity:.7}
    #hud .red{color:var(--red); text-shadow:0 0 5px rgba(255,51,85,.65)}
    #hud .bar{
      height:4px; background:rgba(255,255,255,.12); margin-top:4px; position:relative;
    }
    #hud .bar > i{
      display:block; height:100%; width:50%;
      background:rgba(204,255,204,.9);
    }
    #hud .bar.red > i{ background:rgba(255,51,85,.85); }

    .controls-hint{
      margin-top:16px; text-align:center; opacity:.6; font-size:1.2rem;
    }

    /* Start overlay */
    .start-overlay{
      position:absolute; inset:0; z-index:30;
      display:grid; place-items:center;
      background:radial-gradient(circle at center, rgba(0,0,0,.35), rgba(0,0,0,.92));
      color:var(--green); text-shadow:0 0 8px rgba(204,255,204,.35);
    }
    .panel{
      width:min(520px,92%); border:1px solid rgba(204,255,204,.22);
      background:rgba(0,0,0,.55);
      padding:14px 14px 10px; border-radius:6px;
    }
    .start-title{font-size:3.4rem; letter-spacing:2px; text-align:center; margin:0 0 8px;}
    .start-sub{font-size:1.4rem; opacity:.9; text-align:center; margin:6px 0;}
    .row{display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:10px 0 6px;}
    input,select,button{
      font-family:'VT323'; font-size:1.25rem; padding:8px 10px;
      background:#000; color:var(--fg);
      border:1px solid rgba(255,255,255,.18);
      outline:none;
    }
    input{min-width:220px}
    button{cursor:pointer; border-color:rgba(204,255,204,.35); color:var(--green)}
    button:hover{filter:brightness(1.15)}
    .tiny{opacity:.65; text-align:center; font-size:1.05rem}
  </style>
</head>
<body>

  <div class="crt-monitor" id="crt">
    <div class="scanlines"></div>

    <div id="hud">
      <div id="hudName">NAME: ???</div>
      <div class="dim" id="hudRole">ROLE: ???</div>
      <div class="dim" id="hudRun">RUN: OFF</div>

      <div style="margin-top:6px">
        <div class="dim">OXYGEN</div>
        <div class="bar red"><i id="oxyBar"></i></div>
      </div>

      <div style="margin-top:6px">
        <div class="dim">MISSION</div>
        <div id="hudMission" class="dim">NONE</div>
        <div class="bar"><i id="misBar"></i></div>
      </div>

      <div style="margin-top:6px">
        <div class="dim">LOOT</div>
        <div id="hudLoot" class="dim">CHESTS 0/0</div>
        <div id="hudOffer" class="dim">OFFERINGS 0/0</div>
      </div>

      <div style="margin-top:6px" class="dim">
        DIFFICULTY <span id="hudDiff"></span>
      </div>
    </div>

    <canvas id="gameCanvas" width="320" height="240"></canvas>

    <div id="startOverlay" class="start-overlay">
      <div class="panel">
        <div class="start-title">ENTROPY.DAT</div>
        <div class="start-sub">TYPE YOUR NAME. CHOOSE YOUR ROLE.</div>

        <div class="row">
          <input id="nameInput" type="text" autocomplete="off" spellcheck="false" placeholder="PROTAGONIST NAME">
          <select id="roleInput">
            <option value="thief">THIEF</option>
            <option value="killer">KILLER</option>
            <option value="butcher">BUTCHER</option>
          </select>
        </div>

        <div class="row">
          <button id="startBtn" type="button">CLICK TO INITIALIZE</button>
        </div>

        <div class="tiny">
          WASD / Arrows to move · Shift to run · E = Signal Pulse · 1/2 to answer.<br/>
          Chests unlock missions. Clear mission to unseal exit. Oxygen lasts &gt; 60s.
        </div>
      </div>
    </div>
  </div>

  <div class="controls-hint">
    Shift to run (louder) · E = Signal Pulse · 1/2 respond to messages.<br/>
    The maze has loops. If you die, it’s because you hesitated.
  </div>

<script>
(() => {
  /* ============================================================
     CONFIG
  ============================================================ */
  const TILE = 16;
  const COLS = 20;
  const ROWS = 15;

  const TOTAL_OFFERINGS = 3;
  const CHESTS_PER_LEVEL = 3;

  const BASE_FOV = 6.1;
  const MIN_FOV  = 4.0;
  const MAX_FOV  = 7.2;

  // smooth movement + robust collision
  const PLAYER_RADIUS = 0.28;      // smaller helps corners
  const PLAYER_ACCEL  = 14.0;
  const PLAYER_FRICTION = 0.80;
  const PLAYER_MAX_WALK = 2.15;
  const PLAYER_MAX_RUN  = 3.10;

  // oxygen pacing: baseline must last >= 60s
  const BASE_OXYGEN = 92;  // seconds at WALK drain 1.0
  const RUN_OXY_MULT = 1.55;
  const OXY_TANKS = 3;
  const OXY_TANK_GAIN = 35;

  // difficulty randomization
  const DIFF_LABELS = ["SICKLY", "MEAN", "FAMISHED", "RABID"];
  // monsters per run: 1..3 (kept scary but sane)
  // aggression + oxygen drain vary per run

  // art / color
  const PAL = {
    wall:"#33353f",
    floor:"#09090b",
    stainA:"rgba(160,0,50,0.45)",
    stainB:"rgba(80,0,120,0.35)",
    ui:"#ccffcc",
    danger:"#ff3355",
    player:"#cfe2da"
  };

  /* ============================================================
     DOM
  ============================================================ */
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d", { alpha:false });

  const startOverlay = document.getElementById("startOverlay");
  const startBtn = document.getElementById("startBtn");
  const nameInput = document.getElementById("nameInput");
  const roleInput = document.getElementById("roleInput");

  const hudName = document.getElementById("hudName");
  const hudRole = document.getElementById("hudRole");
  const hudRun  = document.getElementById("hudRun");
  const oxyBar  = document.getElementById("oxyBar");
  const hudMission = document.getElementById("hudMission");
  const misBar  = document.getElementById("misBar");
  const hudLoot = document.getElementById("hudLoot");
  const hudOffer= document.getElementById("hudOffer");
  const hudDiff = document.getElementById("hudDiff");

  /* ============================================================
     STATE
  ============================================================ */
  let gameStarted=false;

  let map=[];
  let keys={};

  let state={
    anxiety:0,
    diffIndex:0,
    monstersCount:1,
    aggression:1.0,
    oxygenDrain:1.0,
    seedSalt:(Math.random()*1e9)|0,
    lore:""
  };

  const hero={
    name:"UNKNOWN",
    role:"thief",
    x:1.5,y:1.5,
    vx:0,vy:0,
    oxygen:BASE_OXYGEN,
    oxygenMax:BASE_OXYGEN,
    panic:0,
    hitCooldown:0,
    // for animated sprite
    animT:0
  };

  let offerings=[];
  let collected=0;

  let exit=null;
  let exitLocked=true;

  let chests=[];
  let stains=[];
  let oxyTanks=[];

  let messages=[]; // floating glitch text

  // prompt (choice)
  let prompt={
    active:false,
    text:"",
    a:"",
    b:"",
    onChoose:null,
    timer:0
  };

  // mission
  let mission={
    active:false,
    completed:false,
    title:"",
    desc:"",
    type:"",
    progress:0,
    goal:1,
    extra:null
  };

  // pulse ring
  let pulse={
    active:false,
    t:0,
    ring:0,
    dirX:0, dirY:0
  };

  // image flash overlays (procedural for now; later you’ll plug in real images)
  let flash={
    active:false,
    t:0,
    dur:0.9,
    img:null,
    alpha:0
  };

  // monsters are “danger zones” (non-solid) to avoid corridor blocking
  let monsters=[]; // {x,y,speed,stun,lastSeen,target,stepCd,faceJitter,faceMode}

  /* ============================================================
     TEXT / LORE
  ============================================================ */
  const crypticPhrases = [
    "IT KNOWS","BEHIND YOU","NULL REFERENCE","WHERE AM I","DONT STOP","STATIC...","1997",
    "DE-SYNC","LOST SIGNAL","FRAME DROP","NO CLIP","PAINTED AIR","NEGATIVE SPACE","FRACTURE","MUTE COLOR",
    "DOOR IS NOT A DOOR","EYES IN THE FOG","YOU ARE DATA","THE MAZE REMEMBERS","THE FLOOR IS BREATHING"
  ];

  const loreFragments = {
    kidnapped: [
      "They took her from a parking lot with a broken streetlight.",
      "A van that smelled like wet carpet and old blood.",
      "You heard the tape recorder start. You never heard it stop.",
      "They said your name like they owned it."
    ],
    thief: [
      "You stole keys you didn't understand.",
      "You can pick locks, but not guilt.",
      "Every door you open remembers your fingerprints."
    ],
    killer: [
      "You did it clean. Too clean.",
      "There are faces in the fog that look like your work.",
      "You keep rehearsing apologies you will never speak."
    ],
    butcher: [
      "You know the weight of meat when it stops being alive.",
      "Your hands remember cuts your mind refuses.",
      "The maze smells familiar."
    ],
    endings: [
      "The exit is not escape. It's upload.",
      "Something will wear your voice after you leave.",
      "Your breath becomes the level geometry."
    ]
  };

  function generateLore(){
    const base = loreFragments.kidnapped[(Math.random()*loreFragments.kidnapped.length)|0];
    const roleLine = loreFragments[hero.role][(Math.random()*loreFragments[hero.role].length)|0];
    const end = loreFragments.endings[(Math.random()*loreFragments.endings.length)|0];
    const name = hero.name.toUpperCase();
    return `${name}, ${base} ${roleLine} ${end}`;
  }

  const lorePrompts = [
    {
      text: (n)=>`A smear on the wall spells: "${n}, DO YOU WANT TO BE SEEN?"`,
      a: "1) YES (clearer view, louder)",
      b: "2) NO  (safer, dimmer)",
      choose: (c)=>{
        if(c===1){ state.anxiety=Math.max(state.anxiety,10); exitLocked=true; state.aggression += 0.10; pushMessage("YOU ARE VISIBLE", PAL.danger); }
        else     { state.aggression = Math.max(0.9, state.aggression-0.08); pushMessage("YOU ARE MISSING", PAL.ui); }
      }
    },
    {
      text: (n)=>`A radio click: "${n}. SACRIFICE OXYGEN FOR SPEED?"`,
      a: "1) ACCEPT (faster, drains more)",
      b: "2) REFUSE (slower, calmer)",
      choose: (c)=>{
        if(c===1){ state.oxygenDrain *= 1.18; pushMessage("HUNGER ENGINE", PAL.danger); }
        else     { state.oxygenDrain = Math.max(0.85, state.oxygenDrain*0.92); state.aggression += 0.06; pushMessage("SLOW MERCY", PAL.ui); }
      }
    },
    {
      text: (n)=>`The CRT whispers: "${n}, WHICH PART OF YOU IS REAL?"`,
      a: "1) HANDS",
      b: "2) VOICE",
      choose: (c)=>{
        if(c===1){ hero.hitCooldown = Math.max(hero.hitCooldown, 0.6); pushMessage("HANDS REMEMBER", "#fff"); }
        else     { state.anxiety = Math.max(state.anxiety, 14); pushMessage("VOICE LIES", PAL.danger); }
      }
    }
  ];

  /* ============================================================
     INPUT (smooth + reliable)
  ============================================================ */
  window.addEventListener("keydown", (e)=>{
    // IMPORTANT: Do not auto-start when typing name
    // Start only via clicking START button.
    keys[e.code]=true;

    if(!gameStarted) return;

    if(e.code==="KeyE") triggerPulse();

    if(prompt.active){
      if(e.code==="Digit1"||e.code==="Numpad1"||e.code==="KeyY") choosePrompt(1);
      if(e.code==="Digit2"||e.code==="Numpad2"||e.code==="KeyN") choosePrompt(2);
    }
  }, {passive:true});
  window.addEventListener("keyup",(e)=>keys[e.code]=false,{passive:true});

  // Start ONLY from button click (not clicking input fields)
  startBtn.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    e.stopPropagation();
    startGame();
  });

  // Prevent overlay clicks from starting (only the button starts)
  startOverlay.addEventListener("pointerdown",(e)=>{
    // allow interacting with inputs/select, but don't start
    e.stopPropagation();
  });

  /* ============================================================
     AUDIO (organic + scary + non-repeating, fear-driven)
  ============================================================ */
  let audio=null;
  function initAudio(){
    if(audio) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    const ac = new AC();

    const master = ac.createGain();
    master.gain.value = 0.75;
    master.connect(ac.destination);

    // noise buffer (pink-ish)
    const noiseBuf = ac.createBuffer(1, ac.sampleRate*2, ac.sampleRate);
    {
      const d = noiseBuf.getChannelData(0);
      let last=0;
      for(let i=0;i<d.length;i++){
        last = 0.965*last + 0.035*(Math.random()*2-1);
        d[i]=last;
      }
    }

    const wind = ac.createBufferSource();
    wind.buffer=noiseBuf; wind.loop=true;
    const windLP = ac.createBiquadFilter();
    windLP.type="lowpass"; windLP.frequency.value=260;
    const windGain=ac.createGain(); windGain.gain.value=0.04;
    wind.connect(windLP); windLP.connect(windGain); windGain.connect(master);
    wind.start();

    const radio = ac.createBufferSource();
    radio.buffer=noiseBuf; radio.loop=true;
    const radioBP=ac.createBiquadFilter();
    radioBP.type="bandpass"; radioBP.frequency.value=1200; radioBP.Q.value=0.9;
    const radioGain=ac.createGain(); radioGain.gain.value=0.015;
    radio.connect(radioBP); radioBP.connect(radioGain); radioGain.connect(master);
    radio.start();

    // organic drone (two oscillators + slow FM)
    const o1=ac.createOscillator(); o1.type="sine"; o1.frequency.value=46;
    const o2=ac.createOscillator(); o2.type="triangle"; o2.frequency.value=69;

    const fm=ac.createOscillator(); fm.type="sine"; fm.frequency.value=0.11;
    const fmGain=ac.createGain(); fmGain.gain.value=11;
    fm.connect(fmGain); fmGain.connect(o1.frequency);

    const droneLP=ac.createBiquadFilter();
    droneLP.type="lowpass"; droneLP.frequency.value=600;

    const droneGain=ac.createGain(); droneGain.gain.value=0.022;

    const mix=ac.createGain(); mix.gain.value=1;

    o1.connect(mix); o2.connect(mix);
    mix.connect(droneLP); droneLP.connect(droneGain); droneGain.connect(master);

    o1.start(); o2.start(); fm.start();

    function blip(intensity=0.4){
      const t=ac.currentTime;
      const osc=ac.createOscillator();
      osc.type = Math.random()<0.5 ? "square":"triangle";
      osc.frequency.value = 80 + Math.random()*2200;

      const bp=ac.createBiquadFilter();
      bp.type="bandpass"; bp.frequency.value = 400 + Math.random()*3200; bp.Q.value=7+Math.random()*5;

      const g=ac.createGain();
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.08*intensity, t+0.003);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.11);

      osc.connect(bp); bp.connect(g); g.connect(master);
      osc.start(t); osc.stop(t+0.12);
    }

    function throb(intensity=0.4){
      const t=ac.currentTime;
      const osc=ac.createOscillator();
      osc.type="sine";
      osc.frequency.value = 24 + Math.random()*18;
      const g=ac.createGain();
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.05*intensity, t+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.35);
      osc.connect(g); g.connect(master);
      osc.start(t); osc.stop(t+0.36);
    }

    function mutate(){
      const t=ac.currentTime;
      const fear=audio?.fear ?? 0;

      radioBP.frequency.setTargetAtTime(600 + Math.random()*3200, t, 1.4);
      radioBP.Q.setTargetAtTime(0.8 + fear*9 + Math.random()*1.2, t, 0.9);
      radioGain.gain.setTargetAtTime(0.010 + 0.03*Math.random() + fear*0.08, t, 0.25);

      windLP.frequency.setTargetAtTime(120 + Math.random()*360, t, 2.2);
      windGain.gain.setTargetAtTime(0.03 + 0.06*Math.random() + fear*0.08, t, 0.6);

      droneLP.frequency.setTargetAtTime(240 + Math.random()*1100 + fear*600, t, 1.7);
      droneGain.gain.setTargetAtTime(0.016 + 0.03*Math.random() + fear*0.08, t, 1.1);

      o1.frequency.setTargetAtTime(36 + Math.random()*40, t, 1.5);
      o2.frequency.setTargetAtTime(54 + Math.random()*70, t, 1.8);

      if(Math.random() < 0.15 + fear*0.25) blip(0.25 + Math.random()*(0.4+fear));
      if(Math.random() < 0.10 + fear*0.18) throb(0.25 + fear*0.9);

      setTimeout(mutate, 800 + Math.random()*1600);
    }

    function eventTick(){
      const fear=audio?.fear ?? 0;
      if(Math.random() < 0.09 + fear*0.25) blip(0.15 + Math.random()*(0.35+fear));
      setTimeout(eventTick, 260 + Math.random()*(950 - fear*450));
    }

    audio = {
      ac, fear:0,
      blip,
      setFear(f){
        audio.fear = f;
      }
    };

    setTimeout(mutate, 600);
    setTimeout(eventTick, 900);
  }

  async function ensureAudioRunning(){
    initAudio();
    if(audio?.ac?.state==="suspended"){
      try { await audio.ac.resume(); } catch {}
    }
  }

  /* ============================================================
     HELPERS
  ============================================================ */
  const clamp=(v,a,b)=> v<a?a : v>b?b : v;
  const inBounds=(x,y)=> x>=0&&y>=0&&x<COLS&&y<ROWS;
  const isFloor=(x,y)=> inBounds(x,y) && map[y][x]===0;

  function randomFloorFar(px,py,manh){
    for(let i=0;i<900;i++){
      const x=(Math.random()*COLS)|0;
      const y=(Math.random()*ROWS)|0;
      if(!isFloor(x,y)) continue;
      if(Math.abs(x-px)+Math.abs(y-py) < manh) continue;
      return {x,y};
    }
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      if(isFloor(x,y) && Math.abs(x-px)+Math.abs(y-py) >= manh) return {x,y};
    }
    return {x:1,y:1};
  }

  function pushMessage(text,color="#fff"){
    messages.push({
      text,
      x: 10 + Math.random()*(canvas.width-20),
      y: 20 + Math.random()*(canvas.height-20),
      life: 70,
      color
    });
  }

  function triggerMessage(text=null){
    if(Math.random()>0.38 && !text) return;
    const phrase = text || crypticPhrases[(Math.random()*crypticPhrases.length)|0];
    pushMessage(phrase, Math.random()>0.5 ? PAL.danger : "#fff");
  }

  /* ============================================================
     BRAIDED MAZE
  ============================================================ */
  function generateBraidedMaze(){
    map = Array(ROWS).fill(0).map(()=>Array(COLS).fill(1));
    const stack=[{x:1,y:1}];
    map[1][1]=0;

    while(stack.length){
      const c=stack[stack.length-1];
      const dirs=[[2,0],[-2,0],[0,2],[0,-2]].sort(()=>Math.random()-0.5);
      let carved=false;
      for(const[dx,dy] of dirs){
        const nx=c.x+dx, ny=c.y+dy;
        if(nx>0&&ny>0&&nx<COLS-1&&ny<ROWS-1&&map[ny][nx]===1){
          map[ny][nx]=0;
          map[c.y+dy/2][c.x+dx/2]=0;
          stack.push({x:nx,y:ny});
          carved=true;break;
        }
      }
      if(!carved) stack.pop();
    }

    // braid dead ends
    for(let y=1;y<ROWS-1;y++){
      for(let x=1;x<COLS-1;x++){
        if(map[y][x]!==0) continue;
        let exits=0;
        const neigh=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const[dX,dY] of neigh){
          if(map[y+dY][x+dX]===0) exits++;
        }
        if(exits===1 && Math.random()<0.62){
          const dirs=neigh.sort(()=>Math.random()-0.5);
          for(const[dX,dY] of dirs){
            if(map[y+dY][x+dX]===1){
              map[y+dY][x+dX]=0;
              break;
            }
          }
        }
      }
    }

    // small extra random loops
    for(let i=0;i<16;i++){
      const x=1+((Math.random()*(COLS-2))|0);
      const y=1+((Math.random()*(ROWS-2))|0);
      if(map[y][x]===1 && Math.random()<0.5){
        map[y][x]=0;
      }
    }
  }

  /* ============================================================
     COLLISION: circle vs walls, robust (no corner sticking)
  ============================================================ */
  function resolveCircleGrid(px,py,r){
    let x=px,y=py;

    // check nearby tiles
    const minX=Math.floor(x-1), maxX=Math.floor(x+1);
    const minY=Math.floor(y-1), maxY=Math.floor(y+1);

    for(let ty=minY; ty<=maxY; ty++){
      for(let tx=minX; tx<=maxX; tx++){
        if(!inBounds(tx,ty) || map[ty][tx]===1){
          // nearest point on tile AABB
          const cx = clamp(x, tx, tx+1);
          const cy = clamp(y, ty, ty+1);
          const dx = x - cx;
          const dy = y - cy;
          const d = Math.hypot(dx,dy);

          if(d < r){
            const push = (r - d) / (d || 1);
            x += dx * push;
            y += dy * push;
          }
        }
      }
    }
    return {x,y};
  }

  /* ============================================================
     OBJECTIVES / SIGNAL PULSE
  ============================================================ */
  function nearestObjective(){
    let best=null, bestD=1e9;

    for(const c of chests){
      if(c.opened) continue;
      const d = Math.hypot((c.x+0.5)-hero.x, (c.y+0.5)-hero.y);
      if(d<bestD){ bestD=d; best={x:c.x,y:c.y}; }
    }
    if(best) return best;

    for(const o of offerings){
      if(o.collected) continue;
      const d = Math.hypot((o.x+0.5)-hero.x, (o.y+0.5)-hero.y);
      if(d<bestD){ bestD=d; best={x:o.x,y:o.y}; }
    }
    if(!best && exit) best={x:exit.x,y:exit.y};
    return best;
  }

  function triggerPulse(){
    if(!gameStarted) return;
    if(pulse.active) return;

    const target = nearestObjective();
    if(!target) return;

    const dx=(target.x+0.5)-hero.x;
    const dy=(target.y+0.5)-hero.y;
    const d=Math.max(1e-6, Math.hypot(dx,dy));

    pulse.active=true;
    pulse.t=0;
    pulse.ring=0;
    pulse.dirX=dx/d;
    pulse.dirY=dy/d;

    state.anxiety = Math.max(state.anxiety, 10);
    audio?.blip?.(1.0);
    pushMessage("ECHO PULSE", "#fff");

    if(mission.active && mission.type==="ECHO_COUNT"){
      mission.extra.used++;
      if(mission.extra.used > mission.extra.max){
        mission.extra.used=0;
        state.anxiety = Math.max(state.anxiety, 16);
        pushMessage("ECHO OVERFLOW", PAL.danger);
      }
    }
  }

  /* ============================================================
     MISSIONS
  ============================================================ */
  function setMission(m){
    mission.active=true;
    mission.completed=false;
    mission.title=m.title;
    mission.desc=m.desc;
    mission.type=m.type;
    mission.progress=0;
    mission.goal=m.goal ?? 1;
    mission.extra=m.extra ?? null;

    exitLocked=true;
    pushMessage(`${hero.name.toUpperCase()}: NEW MISSION`, PAL.ui);
    triggerMessage("NEW TASK LOADED");
  }

  function completeMission(){
    mission.completed=true;
    mission.active=false;
    exitLocked=false;
    triggerMessage("TASK COMPLETE");
    triggerMessage("EXIT UNSEALED");
    audio?.blip?.(1.0);
    state.anxiety = Math.max(0, state.anxiety-4);
  }

  function generateRandomMission(){
    // difficulty scales goals slightly
    const d = state.diffIndex;
    const types=["STILLNESS","NO_RUN","STAIN_TOUCH","ECHO_COUNT","FOLLOW_ORDER"];
    const t=types[(Math.random()*types.length)|0];

    if(t==="STILLNESS"){
      const seconds = 2.2 + Math.random()*2.3 + d*0.35;
      return {
        type:"STILLNESS",
        title:"STILLNESS RITUAL",
        desc:`Stand still near a stain for ${seconds.toFixed(1)}s.\n(Don't move.)`,
        goal:seconds
      };
    }

    if(t==="NO_RUN"){
      const time = 9 + ((Math.random()*9)|0) + d*2;
      return {
        type:"NO_RUN",
        title:"SILENT WALK",
        desc:`Survive ${time}s without sprinting.\n(Shift forbidden.)`,
        goal:time
      };
    }

    if(t==="STAIN_TOUCH"){
      const count = 2 + ((Math.random()*2)|0) + (d>1?1:0);
      return {
        type:"STAIN_TOUCH",
        title:"TOUCH THE CORRUPTION",
        desc:`Step into ${count} different stains.\n(Each counts once.)`,
        goal:count,
        extra:{touched:new Set()}
      };
    }

    if(t==="ECHO_COUNT"){
      const pulses = 2 + ((Math.random()*2)|0) + (d>2?1:0);
      return {
        type:"ECHO_COUNT",
        title:"ECHO TEST",
        desc:`Use Signal Pulse (E) exactly ${pulses} times.\n(Too many resets.)`,
        goal:pulses,
        extra:{used:0,max:pulses}
      };
    }

    // FOLLOW_ORDER
    const order=[1,2,3].sort(()=>Math.random()-0.5);
    offerings.forEach((o,i)=>o.order=order[i]);
    return {
      type:"FOLLOW_ORDER",
      title:"SEQUENCE OF OFFERINGS",
      desc:`Collect offerings in correct sequence.\n(Colors indicate order.)`,
      goal:TOTAL_OFFERINGS,
      extra:{needed:1}
    };
  }

  function updateMission(dt, moving, sprinting){
    if(!mission.active) return;

    if(mission.type==="STILLNESS"){
      const near = stains.some(s=>Math.hypot((s.x+0.5)-hero.x,(s.y+0.5)-hero.y)<2.0);
      if(!moving && near) mission.progress += dt;
      else mission.progress = Math.max(0, mission.progress - dt*0.9);
      if(mission.progress >= mission.goal) completeMission();
      return;
    }

    if(mission.type==="NO_RUN"){
      if(sprinting){
        mission.progress = Math.max(0, mission.progress - dt*2.2);
        if(Math.random()<0.02) triggerMessage("TOO LOUD");
        state.anxiety = Math.max(state.anxiety, 12);
      } else {
        mission.progress += dt;
      }
      if(mission.progress >= mission.goal) completeMission();
      return;
    }

    if(mission.type==="STAIN_TOUCH"){
      for(const s of stains){
        if(Math.hypot((s.x+0.5)-hero.x,(s.y+0.5)-hero.y) < 0.95){
          mission.extra.touched.add(`${s.x},${s.y}`);
        }
      }
      mission.progress = mission.extra.touched.size;
      if(mission.progress >= mission.goal) completeMission();
      return;
    }

    if(mission.type==="ECHO_COUNT"){
      mission.progress = mission.extra.used;
      if(mission.progress >= mission.goal) completeMission();
      return;
    }

    if(mission.type==="FOLLOW_ORDER"){
      mission.progress = collected;
      return;
    }
  }

  /* ============================================================
     PROMPT (choices)
  ============================================================ */
  function showPrompt(p){
    if(prompt.active) return;
    prompt.active=true;
    prompt.text = p.text(hero.name.toUpperCase());
    prompt.a = p.a;
    prompt.b = p.b;
    prompt.onChoose = p.choose;
    prompt.timer = 6.6;
    pushMessage("INPUT REQUIRED", PAL.ui);
    state.anxiety = Math.max(state.anxiety, 10);
  }

  function choosePrompt(choice){
    if(!prompt.active) return;
    const fn=prompt.onChoose;
    prompt.active=false;
    if(fn) fn(choice);
    audio?.blip?.(0.9);
  }

  /* ============================================================
     CREEPY IMAGE FLASH (procedural now; later swap with your images)
  ============================================================ */
  function generateCreepyImage(kind="face"){
    const c=document.createElement("canvas");
    c.width=160; c.height=120;
    const g=c.getContext("2d");
    g.fillStyle="#000"; g.fillRect(0,0,c.width,c.height);

    // noisy base
    for(let i=0;i<3200;i++){
      const x=(Math.random()*c.width)|0;
      const y=(Math.random()*c.height)|0;
      const v=(Math.random()*60)|0;
      g.fillStyle=`rgb(${v},${v},${v})`;
      g.fillRect(x,y,1,1);
    }

    // red smears
    g.globalAlpha=0.25;
    for(let i=0;i<10;i++){
      g.fillStyle = Math.random()<0.5 ? "rgb(140,0,30)" : "rgb(80,0,120)";
      g.fillRect((Math.random()*c.width)|0, (Math.random()*c.height)|0, 10+(Math.random()*70|0), 2+(Math.random()*10|0));
    }
    g.globalAlpha=1;

    // abstract face
    if(kind==="face"){
      const cx=c.width/2 + (Math.random()*18-9);
      const cy=c.height/2 + (Math.random()*12-6);
      const eyeY=cy-10 + Math.random()*6;
      const eyeDX=28 + Math.random()*12;

      g.fillStyle="rgba(255,60,90,0.65)";
      g.fillRect(cx-eyeDX, eyeY, 9, 4);
      g.fillRect(cx+eyeDX-9, eyeY, 9, 4);

      g.fillStyle="rgba(0,0,0,0.9)";
      g.fillRect(cx-eyeDX+4, eyeY+1, 2, 2);
      g.fillRect(cx+eyeDX-6, eyeY+1, 2, 2);

      g.fillStyle="rgba(255,255,255,0.12)";
      g.fillRect(cx-22, cy+14, 44, 3);

      g.fillStyle="rgba(255,60,90,0.22)";
      for(let i=0;i<7;i++){
        const x=cx+(Math.random()*90-45);
        const y=(Math.random()*c.height)|0;
        g.fillRect(x,y,1,10+(Math.random()*40|0));
      }
    }

    // glitch smear
    g.globalAlpha=0.22;
    for(let i=0;i<7;i++){
      const y=(Math.random()*c.height)|0;
      const dx=(Math.random()*26-13);
      g.drawImage(c, 0, y, c.width, 2, dx, y, c.width, 2);
    }
    g.globalAlpha=1;

    return c;
  }

  function triggerFlash(kind="face"){
    flash.active=true;
    flash.t=0;
    flash.dur=0.65 + Math.random()*0.8;
    flash.img=generateCreepyImage(kind);
    flash.alpha=0;
  }

  /* ============================================================
     MONSTER SPRITE (procedural image, jitter)
  ============================================================ */
  function makeMonsterSprite(){
    const c=document.createElement("canvas");
    c.width=20; c.height=20;
    const g=c.getContext("2d");
    g.clearRect(0,0,20,20);
    g.fillStyle="rgba(30,30,42,0.95)";
    g.fillRect(4,4,12,12);

    // eyes
    g.fillStyle="rgba(255,60,90,0.85)";
    g.fillRect(7,10,2,1);
    g.fillRect(11,10,2,1);

    // mouth void
    g.fillStyle="rgba(0,0,0,0.9)";
    g.fillRect(8,13,4,2);

    for(let i=0;i<30;i++){
      const x=(Math.random()*20)|0;
      const y=(Math.random()*20)|0;
      g.fillStyle = Math.random()<0.5 ? "rgba(255,60,90,0.10)" : "rgba(255,255,255,0.08)";
      g.fillRect(x,y,1,1);
    }
    return c;
  }
  const monsterSprite = makeMonsterSprite();

  /* ============================================================
     MONSTERS (aggressive, but cannot physically block)
  ============================================================ */
  function spawnMonsters(){
    monsters=[];
    for(let i=0;i<state.monstersCount;i++){
      const r=randomFloorFar(1,1, 12 + i*2);
      monsters.push({
        x:r.x+0.5,
        y:r.y+0.5,
        speed:(0.95 + Math.random()*0.35) * (0.55 + state.diffIndex*0.16),
        stun:0,
        lastSeen:0,
        stepCd:0,
        target:null,
        faceJitter:0,
        faceMode:0 // used to trigger face flashes when close
      });
    }
  }

  function pickNeighborStep(mx,my,tx,ty){
    const gx=Math.floor(mx), gy=Math.floor(my);
    const opts=[
      {x:gx+1,y:gy},{x:gx-1,y:gy},{x:gx,y:gy+1},{x:gx,y:gy-1}
    ].filter(p=>isFloor(p.x,p.y));
    if(!opts.length) return null;
    let best=opts[0], bestScore=1e9;
    for(const o of opts){
      const d=Math.hypot((o.x+0.5)-tx,(o.y+0.5)-ty);
      const wob=(Math.random()-0.5)*0.35;
      const score=d+wob;
      if(score<bestScore){ bestScore=score; best=o; }
    }
    return best;
  }

  function updateMonsters(dt){
    // distance to closest monster controls fear/audio and some visuals
    let closest=999;

    for(const m of monsters){
      const dx=hero.x-m.x, dy=hero.y-m.y;
      const dist=Math.max(1e-6, Math.hypot(dx,dy));
      closest=Math.min(closest, dist);

      if(m.stun>0){ m.stun=Math.max(0, m.stun-dt); continue; }

      const sprinting=!!keys.ShiftLeft;
      const hearRadius = sprinting ? 7.8 : 4.8;

      let tx=m.x, ty=m.y;

      if(dist < hearRadius){
        m.lastSeen=1.4;
        tx=hero.x; ty=hero.y;
      } else if(m.lastSeen>0){
        m.lastSeen=Math.max(0, m.lastSeen-dt);
        tx = m.x + (dx/dist)*1.0;
        ty = m.y + (dy/dist)*1.0;
      } else {
        const s=stains[(Math.random()*stains.length)|0];
        tx=s.x+0.5; ty=s.y+0.5;
      }

      m.stepCd -= dt;
      if(m.stepCd<=0 || !m.target){
        m.stepCd = 0.14 + Math.random()*0.20;
        const step=pickNeighborStep(m.x,m.y,tx,ty);
        if(step) m.target=step;
      }

      if(m.target){
        const cx=m.target.x+0.5, cy=m.target.y+0.5;
        const mdx=cx-m.x, mdy=cy-m.y;
        const md=Math.max(1e-6, Math.hypot(mdx,mdy));
        m.x += (mdx/md) * (m.speed*state.aggression) * dt * 3.3;
        m.y += (mdy/md) * (m.speed*state.aggression) * dt * 3.3;
        if(md<0.08) m.stepCd=0;
      }

      // close-range horror without “blocking”
      if(dist < 3.2){
        state.anxiety = Math.max(state.anxiety, 9 + (3.2-dist)*4.5);
        if(Math.random()<0.035) triggerMessage();
      }

      // face flash when very close (your future uploaded images plug here)
      if(dist < 2.0 && Math.random() < 0.006 + state.diffIndex*0.003){
        triggerFlash("face");
      }

      // damage zone (but never an impassable wall: you *can* risk running through)
      if(hero.hitCooldown>0) hero.hitCooldown = Math.max(0, hero.hitCooldown-dt);
      if(dist < 0.62 && hero.hitCooldown<=0){
        hero.hitCooldown=0.75;
        hero.panic++;
        hero.oxygen = Math.max(0, hero.oxygen - (12 + state.diffIndex*4));
        triggerMessage("DON'T LOOK");
        audio?.blip?.(1.0);
        triggerFlash("face");

        // shove the player away slightly (no corner stick thanks to collision resolver)
        hero.x += (dx/dist)*0.40;
        hero.y += (dy/dist)*0.40;
        const r=resolveCircleGrid(hero.x, hero.y, PLAYER_RADIUS);
        hero.x=r.x; hero.y=r.y;

        if(hero.panic>=3){
          gameOver("CAUGHT IN THE BUFFER");
          return;
        }
      }
    }

    const fear = clamp(1 - closest/6, 0, 1);
    audio?.setFear?.(fear);
  }

  /* ============================================================
     LEVEL GEN
  ============================================================ */
  function generateLevel(){
    generateBraidedMaze();

    // stains
    stains=[];
    for(let i=0;i<8;i++) stains.push(randomFloorFar(1,1,4));

    // offerings
    offerings=[];
    while(offerings.length<TOTAL_OFFERINGS){
      const r=randomFloorFar(1,1,6);
      if(offerings.some(o=>o.x===r.x&&o.y===r.y)) continue;
      offerings.push({x:r.x,y:r.y,collected:false,order:0});
    }

    // chests
    chests=[];
    while(chests.length<CHESTS_PER_LEVEL){
      const r=randomFloorFar(1,1,5);
      if(chests.some(c=>c.x===r.x&&c.y===r.y)) continue;
      if(offerings.some(o=>o.x===r.x&&o.y===r.y)) continue;
      chests.push({x:r.x,y:r.y,opened:false});
    }

    // oxygen tanks
    oxyTanks=[];
    while(oxyTanks.length<OXY_TANKS){
      const r=randomFloorFar(1,1,6);
      if(offerings.some(o=>o.x===r.x&&o.y===r.y)) continue;
      if(chests.some(c=>c.x===r.x&&c.y===r.y)) continue;
      oxyTanks.push({x:r.x,y:r.y,used:false});
    }

    // exit
    exit=randomFloorFar(1,1,12);
    exitLocked=true;

    collected=0;
    messages=[];
    state.anxiety=0;

    hero.x=1.5; hero.y=1.5;
    hero.vx=0; hero.vy=0;
    hero.oxygen=hero.oxygenMax;
    hero.panic=0;
    hero.hitCooldown=0;
    hero.animT=0;

    mission.active=false;
    mission.completed=false;
    prompt.active=false;
    pulse.active=false;
    flash.active=false;

    spawnMonsters();
    updateHUD();
  }

  /* ============================================================
     PICKUPS / INTERACTIONS
  ============================================================ */
  function openChest(c){
    c.opened=true;
    triggerMessage("CHEST OPENED");
    audio?.blip?.(1.0);
    if(Math.random()<0.78) triggerFlash("face");

    // chest unlocks mission if locked; else triggers lore prompt
    if(!mission.active && exitLocked){
      setMission(generateRandomMission());
    } else if(Math.random()<0.6){
      showPrompt(lorePrompts[(Math.random()*lorePrompts.length)|0]);
    }
  }

  function collectOffering(o){
    // FOLLOW_ORDER enforcement
    if(mission.active && mission.type==="FOLLOW_ORDER"){
      const needed = (mission.extra?.needed ?? 1);
      if(o.order !== needed){
        triggerMessage("WRONG SEQUENCE");
        state.anxiety = Math.max(state.anxiety, 18);
        audio?.blip?.(1.0);
        triggerFlash("face");
        // reset level: cruel but fair
        generateLevel();
        return;
      }
      mission.extra.needed = needed+1;
      if(mission.extra.needed > TOTAL_OFFERINGS){
        completeMission();
      }
    }

    o.collected=true;
    collected++;
    triggerMessage("OFFERING ACCEPTED");
    pushMessage(`${hero.name.toUpperCase()}: MEMORY INDEXED`, "#fff");
    audio?.blip?.(0.9);

    if(Math.random()<0.55) triggerFlash("face");
    if(Math.random()<0.32) showPrompt(lorePrompts[(Math.random()*lorePrompts.length)|0]);

    // spawn exit only when mission completed/unlocked (exitLocked=false)
    updateHUD();
  }

  function takeOxy(t){
    t.used=true;
    hero.oxygen = Math.min(hero.oxygenMax, hero.oxygen + OXY_TANK_GAIN);
    pushMessage("OXYGEN TANK", PAL.ui);
    audio?.blip?.(0.6);
  }

  /* ============================================================
     UI / HUD
  ============================================================ */
  function updateHUD(){
    hudName.textContent = `NAME: ${hero.name.toUpperCase()}`;
    hudRole.textContent = `ROLE: ${hero.role.toUpperCase()}`;
    hudLoot.textContent = `CHESTS ${chests.filter(c=>c.opened).length}/${CHESTS_PER_LEVEL}`;
    hudOffer.textContent = `OFFERINGS ${collected}/${TOTAL_OFFERINGS}`;

    hudMission.textContent = mission.active ? mission.title : (exitLocked ? "LOCKED" : "UNSEALED");
    const mpct = mission.active ? clamp(mission.progress/mission.goal,0,1) : (exitLocked?0:1);
    misBar.style.width = `${(mpct*100)|0}%`;

    const opct = clamp(hero.oxygen/hero.oxygenMax,0,1);
    oxyBar.style.width = `${(opct*100)|0}%`;

    hudDiff.textContent = DIFF_LABELS[state.diffIndex] + ` · M${state.monstersCount}`;
  }

  /* ============================================================
     NOISE / VISUAL FX
  ============================================================ */
  function drawNoise(amount){
    if(amount<=0) return;
    ctx.save();
    ctx.globalAlpha = Math.min(0.24, amount/50);
    for(let i=0;i<140;i++){
      const x=Math.random()*canvas.width;
      const y=Math.random()*canvas.height;
      const w=1+Math.random()*2;
      const h=1+Math.random()*2;
      ctx.fillStyle = Math.random()<0.5 ? "#0b0b0b" : "#171717";
      ctx.fillRect(x,y,w,h);
    }
    ctx.restore();
  }

  /* ============================================================
     UPDATE LOOP
  ============================================================ */
  let lastT=performance.now();

  function update(){
    const now=performance.now();
    const dt=Math.min(0.05,(now-lastT)/1000);
    lastT=now;

    // prompt timer
    if(prompt.active){
      prompt.timer -= dt;
      if(prompt.timer<=0){
        prompt.active=false;
        triggerMessage("NO RESPONSE");
        state.anxiety = Math.max(state.anxiety, 14);
        state.aggression += 0.06;
      }
    }

    // oxygen drain
    const sprinting = !!keys.ShiftLeft;
    hudRun.textContent = `RUN: ${sprinting?"ON":"OFF"}`;

    const drain = state.oxygenDrain * (sprinting ? RUN_OXY_MULT : 1.0);
    hero.oxygen = Math.max(0, hero.oxygen - drain*dt);

    if(hero.oxygen<=0){
      gameOver("NO AIR LEFT");
      return;
    }

    // movement (smooth acceleration)
    let ix=0,iy=0;
    if(keys.KeyW||keys.ArrowUp) iy -= 1;
    if(keys.KeyS||keys.ArrowDown) iy += 1;
    if(keys.KeyA||keys.ArrowLeft) ix -= 1;
    if(keys.KeyD||keys.ArrowRight) ix += 1;

    if(ix||iy){
      const l=Math.hypot(ix,iy); ix/=l; iy/=l;
    }

    const maxSpeed = sprinting ? PLAYER_MAX_RUN : PLAYER_MAX_WALK;

    // accel -> velocity
    hero.vx += ix * PLAYER_ACCEL * dt;
    hero.vy += iy * PLAYER_ACCEL * dt;

    // clamp speed
    const sp=Math.hypot(hero.vx, hero.vy);
    if(sp > maxSpeed){
      hero.vx *= maxSpeed/sp;
      hero.vy *= maxSpeed/sp;
    }

    // friction
    hero.vx *= Math.pow(PLAYER_FRICTION, dt*60);
    hero.vy *= Math.pow(PLAYER_FRICTION, dt*60);

    // integrate + resolve collisions robustly
    let nx = hero.x + hero.vx*dt;
    let ny = hero.y + hero.vy*dt;
    let r = resolveCircleGrid(nx, ny, PLAYER_RADIUS);
    hero.x=r.x; hero.y=r.y;

    const moving = Math.abs(hero.vx)+Math.abs(hero.vy) > 0.01;

    // anxiety rises with sprinting + proximity to stains
    if(sprinting) state.anxiety = Math.min(state.anxiety + 0.35, 18);
    else state.anxiety = Math.max(state.anxiety - 0.12, 0);

    for(const s of stains){
      const d=Math.hypot((s.x+0.5)-hero.x, (s.y+0.5)-hero.y);
      if(d<1.05){
        state.anxiety = Math.max(state.anxiety, 7);
        if(Math.random()<0.014) triggerMessage("COLOR BLEED");
        if(Math.random()<0.005) showPrompt(lorePrompts[(Math.random()*lorePrompts.length)|0]);
      }
    }

    // mission logic
    updateMission(dt, moving, sprinting);

    // monsters
    updateMonsters(dt);

    // pickups
    for(const c of chests){
      if(c.opened) continue;
      if(Math.hypot((c.x+0.5)-hero.x,(c.y+0.5)-hero.y) < 0.72) openChest(c);
    }

    for(const o of offerings){
      if(o.collected) continue;
      if(Math.hypot((o.x+0.5)-hero.x,(o.y+0.5)-hero.y) < 0.72) collectOffering(o);
    }

    for(const t of oxyTanks){
      if(t.used) continue;
      if(Math.hypot((t.x+0.5)-hero.x,(t.y+0.5)-hero.y) < 0.72) takeOxy(t);
    }

    // exit
    if(exit && !exitLocked){
      if(Math.hypot((exit.x+0.5)-hero.x,(exit.y+0.5)-hero.y) < 0.62){
        win();
        return;
      }
    }

    // pulse ring
    if(pulse.active){
      pulse.t += dt*12;
      pulse.ring = pulse.t;
      if(pulse.t > 25) pulse.active=false;
    }

    // flash fade
    if(flash.active){
      flash.t += dt;
      if(flash.t < flash.dur*0.2) flash.alpha = flash.t/(flash.dur*0.2);
      else flash.alpha = 1 - (flash.t - flash.dur*0.2)/(flash.dur*0.8);

      if(flash.t >= flash.dur){
        flash.active=false;
        flash.alpha=0;
      }
    }

    // messages
    for(let i=messages.length-1;i>=0;i--){
      messages[i].life--;
      if(messages[i].life<=0) messages.splice(i,1);
    }

    // animate hero sprite
    hero.animT += dt;

    updateHUD();
  }

  /* ============================================================
     RENDER
  ============================================================ */
  function render(){
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // camera centered on hero (but no huge shakes; keep playable)
    const shake = Math.min(6, state.anxiety*0.45);
    const sx = (Math.random()-0.5)*shake;
    const sy = (Math.random()-0.5)*shake;

    const camX = -hero.x*TILE + canvas.width/2 + sx;
    const camY = -hero.y*TILE + canvas.height/2 + sy;

    // dynamic FOV by anxiety + pulse
    const viewRadius = clamp(BASE_FOV - (state.anxiety/5) + (pulse.active?2.4:0), MIN_FOV, MAX_FOV);

    // map layer
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const dist = Math.hypot((x+0.5)-hero.x,(y+0.5)-hero.y);

        let vis=0;
        if(dist < viewRadius){
          vis = 1 - (dist/viewRadius);
          vis = Math.pow(vis, 0.62);
        }

        // pulse ring lighting
        if(pulse.active){
          const pd=dist;
          if(Math.abs(pd - pulse.ring) < 1.5){
            vis += 0.48 * (1 - (Math.abs(pd-pulse.ring)/1.5));
          }
        }

        if(vis <= 0.01) continue;
        vis = clamp(vis,0,1);

        const px = camX + x*TILE;
        const py = camY + y*TILE;

        ctx.save();
        ctx.globalAlpha = vis;

        if(map[y][x]===1){
          ctx.fillStyle = PAL.wall;
          ctx.fillRect(px,py,TILE,TILE);
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.strokeRect(px,py,TILE,TILE);
        } else {
          ctx.fillStyle = PAL.floor;
          ctx.fillRect(px,py,TILE,TILE);

          const st = stains.find(s=>s.x===x && s.y===y);
          if(st){
            ctx.fillStyle = Math.random()<0.5 ? PAL.stainA : PAL.stainB;
            ctx.fillRect(px,py,TILE,TILE);
          }
        }
        ctx.restore();
      }
    }

    // objects
    function drawObj(tx,ty,color,shape){
      const dist = Math.hypot((tx+0.5)-hero.x,(ty+0.5)-hero.y);
      if(dist > viewRadius && !(pulse.active && Math.abs(dist-pulse.ring)<1.5)) return;

      const x = camX + tx*TILE;
      const y = camY + ty*TILE;

      ctx.fillStyle=color;
      if(shape==="box") ctx.fillRect(x+4,y+4,8,8);
      else if(shape==="circle"){
        ctx.beginPath(); ctx.arc(x+8,y+8,4,0,Math.PI*2); ctx.fill();
      } else if(shape==="diamond"){
        ctx.beginPath();
        ctx.moveTo(x+8,y+2); ctx.lineTo(x+14,y+8);
        ctx.lineTo(x+8,y+14); ctx.lineTo(x+2,y+8);
        ctx.closePath(); ctx.fill();
      }
    }

    chests.forEach(c=>{ if(!c.opened) drawObj(c.x,c.y,"#3a88aa","box"); });

    offerings.forEach(o=>{
      if(o.collected) return;
      const col = (mission.active && mission.type==="FOLLOW_ORDER")
        ? (o.order===1 ? "#ff3355" : o.order===2 ? "#44ff88" : "#4488ff")
        : "#ddcc44";
      drawObj(o.x,o.y,col,"circle");
    });

    oxyTanks.forEach(t=>{
      if(!t.used) drawObj(t.x,t.y,"#55ddff","box");
    });

    if(exit){
      drawObj(exit.x, exit.y, exitLocked ? "#550000" : "#ffffff", "diamond");
      if(!exitLocked){
        // “door slit”
        const x = camX + exit.x*TILE;
        const y = camY + exit.y*TILE;
        ctx.fillStyle="rgba(255,60,90,0.7)";
        ctx.fillRect(x+7,y+3,2,TILE-6);
      }
    }

    // monsters
    for(const m of monsters){
      const dist = Math.hypot(m.x-hero.x, m.y-hero.y);
      if(dist < viewRadius + 1.6){
        const x = camX + m.x*TILE - 10;
        const y = camY + m.y*TILE - 10;
        const jx=(Math.random()-0.5)*2;
        const jy=(Math.random()-0.5)*2;
        ctx.globalAlpha = 0.85;
        ctx.drawImage(monsterSprite, x+jx, y+jy);
        ctx.globalAlpha = 1;
      }
    }

    // hero sprite (animated creepy figure, role-based tint)
    const hx = canvas.width/2;
    const hy = canvas.height/2;
    const breath = 1 + Math.sin(hero.animT*3.2)*0.08;
    const jitter = (Math.random()-0.5) * (0.6 + state.anxiety*0.08);

    // base body
    let tint = hero.role==="thief" ? "rgba(180,220,210,0.95)"
             : hero.role==="killer" ? "rgba(220,190,200,0.95)"
             : "rgba(220,210,180,0.95)";

    ctx.save();
    ctx.translate(hx+jitter, hy+jitter);

    // shadow smear
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(255,60,90,0.35)";
    ctx.fillRect(-4, -3, 8, 8);
    ctx.globalAlpha = 1;

    ctx.fillStyle = tint;
    ctx.fillRect(-2, -2, 4, 4*breath);

    // “head” pixel
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.fillRect(-1, -4, 2, 2);

    // role mark
    ctx.fillStyle = hero.role==="thief" ? "rgba(80,255,200,0.65)"
               : hero.role==="killer" ? "rgba(255,80,140,0.65)"
               : "rgba(255,210,80,0.65)";
    ctx.fillRect(-3, 1, 1, 1);
    ctx.fillRect( 2, 1, 1, 1);

    ctx.restore();

    // flash overlay
    if(flash.active && flash.img){
      ctx.globalAlpha = flash.alpha*0.85;
      ctx.drawImage(flash.img, 0,0, canvas.width, canvas.height);
      ctx.globalAlpha = 1;
    }

    // anxiety noise
    drawNoise(state.anxiety);

    // floating messages
    ctx.font="14px VT323";
    ctx.textAlign="left";
    for(const m of messages){
      ctx.fillStyle=m.color;
      ctx.globalAlpha = Math.min(1, m.life/20);
      ctx.fillText(m.text, m.x, m.y);
    }
    ctx.globalAlpha=1;

    // prompt / mission UI (in-canvas, centered, readable)
    if(prompt.active){
      ctx.fillStyle="rgba(0,0,0,0.88)";
      ctx.fillRect(18, 150, 284, 76);
      ctx.strokeStyle="rgba(204,255,204,0.65)";
      ctx.strokeRect(18, 150, 284, 76);

      ctx.fillStyle="#fff";
      ctx.textAlign="center";
      ctx.fillText(prompt.text, 160, 170);
      ctx.fillStyle="#bbb";
      ctx.fillText(prompt.a, 160, 192);
      ctx.fillText(prompt.b, 160, 208);

      // timer bar
      ctx.fillStyle=PAL.danger;
      ctx.fillRect(20, 222, 280*clamp(prompt.timer/6.6,0,1), 2);

      ctx.textAlign="left";
    } else if(mission.active){
      // small mission box, bottom left-ish but not blocking
      ctx.fillStyle="rgba(0,0,0,0.55)";
      ctx.fillRect(6, 200, 170, 34);
      ctx.strokeStyle="rgba(204,255,204,0.25)";
      ctx.strokeRect(6, 200, 170, 34);

      ctx.fillStyle=PAL.ui;
      ctx.fillText(mission.title, 10, 212);

      const pct=clamp(mission.progress/mission.goal,0,1);
      ctx.fillStyle="rgba(255,255,255,0.16)";
      ctx.fillRect(10, 217, 100, 4);
      ctx.fillStyle=PAL.ui;
      ctx.fillRect(10, 217, 100*pct, 4);

      ctx.fillStyle="#aaa";
      const line = mission.desc.split("\n")[1] || "";
      ctx.fillText(line, 10, 232);
    }
  }

  /* ============================================================
     MAIN LOOP
  ============================================================ */
  function tick(){
    if(gameStarted){
      update();
      render();
    } else {
      // idle background noise
      ctx.fillStyle="#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      drawNoise(6);
    }
    requestAnimationFrame(tick);
  }

  /* ============================================================
     GAME START / END
  ============================================================ */
  function pickDifficulty(){
    // 0..3
    state.diffIndex = (Math.random()*4)|0;
    state.monstersCount = 1 + ((Math.random()*2)|0) + (state.diffIndex>1?1:0); // 1..3
    state.aggression = 0.95 + state.diffIndex*0.12 + Math.random()*0.08;
    state.oxygenDrain = 0.92 + state.diffIndex*0.12 + Math.random()*0.10;

    // role tweaks (subtle)
    if(hero.role==="thief"){
      // slightly better oxygen economy
      state.oxygenDrain *= 0.94;
    } else if(hero.role==="killer"){
      // more aggressive monsters
      state.aggression *= 1.06;
    } else if(hero.role==="butcher"){
      // oxygen tanks more valuable (same gain, but max slightly higher)
      hero.oxygenMax = BASE_OXYGEN + 10;
    }
  }

  async function startGame(){
    if(gameStarted) return;

    // read inputs (typing should NOT start, only button does)
    const nm = (nameInput.value || "").trim();
    hero.name = nm ? nm.slice(0,18) : "UNKNOWN";
    hero.role = roleInput.value || "thief";
    hero.oxygenMax = BASE_OXYGEN;
    hero.oxygen = hero.oxygenMax;

    state.lore = generateLore();

    startOverlay.style.display="none";
    await ensureAudioRunning();

    pickDifficulty();
    pushMessage(state.lore, "#fff");
    triggerMessage("BOOTING LEVEL");

    generateLevel();
    gameStarted=true;
  }

  function gameOver(reason){
    gameStarted=false;
    alert(`${reason}\n\nRUN END.\n${hero.name.toUpperCase()} WAS ARCHIVED.`);
    location.reload();
  }

  function win(){
    gameStarted=false;
    alert(`EXIT UNSEALED.\n${hero.name.toUpperCase()} WAS UPLOADED.\n\nTHE MAZE SAVES COPIES.`);
    location.reload();
  }

  /* ============================================================
     BOOT
  ============================================================ */
  // Start idle loop immediately
  updateHUD();
  tick();

})();
</script>

</body>
</html>

